
------------------------------------------------------------
ПУТЬ: pkg -> f2f -> api.go
------------------------------------------------------------
package f2f

import (
	"context"
	"encoding/base64"
	"fmt"
	"sync"
	"time"

	dht "github.com/libp2p/go-libp2p-kad-dht"
	"github.com/libp2p/go-libp2p/core/peer"
	"github.com/multiformats/go-multiaddr"
)

func (n *Node) Login(nickname string) {
	// Fix #2: Валидация никнейма
	if err := n.validateNickname(nickname); err != nil {
		n.Log(LogLevelError, "Ошибка входа: %v", err)
		return
	}

	n.mu.Lock()
	n.nickname = nickname
	n.mu.Unlock()
	n.saveIdentity()
	n.Log(LogLevelSuccess, "Вы: %s", nickname)
}

func (n *Node) GetIdentityString() string {
	n.mu.RLock()
	nick := n.nickname
	n.mu.RUnlock()

	if nick == "" {
		return "Не залогинен"
	}
	// Примечание: n.naclPublic immutable после старта, читать без лока безопасно,
	// но для чистоты архитектуры можно было бы держать лок до конца.
	pubKeyB64 := base64.StdEncoding.EncodeToString(n.naclPublic[:])
	return fmt.Sprintf(".addfriend %s %s %s", nick, n.host.ID().String(), pubKeyB64)
}

func (n *Node) ConnectToBootstrap() {
	n.Log(LogLevelInfo, "Подключение к DHT...")
	var wg sync.WaitGroup
	connected := 0
	var mu sync.Mutex

	for _, addrInfo := range dht.DefaultBootstrapPeers {
		wg.Add(1)
		go func(info multiaddr.Multiaddr) {
			defer wg.Done()
			ai, err := peer.AddrInfoFromP2pAddr(info)
			if err != nil {
				return
			}
			ctx, cancel := context.WithTimeout(n.ctx, BootstrapTimeout)
			defer cancel()
			if err := n.host.Connect(ctx, *ai); err == nil {
				mu.Lock()
				connected++
				mu.Unlock()
			}
		}(addrInfo)
	}
	wg.Wait()

	if connected > 0 {
		n.Log(LogLevelSuccess, "Подключено к %d узлам", connected)
		// Fix #1: Убрали Sleep блокирующий, заменили на select
		n.wg.Add(1)
		go func() {
			defer n.wg.Done()
			select {
			case <-time.After(3 * time.Second):
				n.ForceCheckAll()
			case <-n.ctx.Done():
				return
			}
		}()
	} else {
		n.Log(LogLevelError, "Не удалось подключиться к DHT")
	}
}

func (n *Node) AddFriend(nickname, peerIDStr, pubKeyB64 string) {
	if err := n.validateNickname(nickname); err != nil {
		n.Log(LogLevelError, "Некорректный ник: %v", err)
		return
	}

	peerID, err := peer.Decode(peerIDStr)
	if err != nil {
		n.Log(LogLevelError, "Ошибка PeerID")
		return
	}
	if peerID == n.host.ID() {
		n.Log(LogLevelError, "Нельзя добавить себя")
		return
	}

	pubBytes, err := base64.StdEncoding.DecodeString(pubKeyB64)
	if err != nil || len(pubBytes) != 32 {
		n.Log(LogLevelError, "Ошибка ключа")
		return
	}
	var pubKey [32]byte
	copy(pubKey[:], pubBytes)

	n.mu.Lock()
	if _, exists := n.nickMap[nickname]; exists {
		n.mu.Unlock()
		n.Log(LogLevelError, "Ник '%s' занят", nickname)
		return
	}
	contact := &Contact{
		Nickname:   nickname,
		PeerID:     peerID,
		PublicKey:  pubKey,
		SeenNonces: make(map[int64]time.Time),
		State:      StateIdle,
		Presence:   PresenceUnknown,
	}
	n.contacts[peerID] = contact
	n.nickMap[nickname] = peerID
	n.mu.Unlock()

	n.Log(LogLevelSuccess, "Добавлен: %s", nickname)
	n.SaveContacts()
	// Fix #6: Safe listener
	n.notifyContactUpdate()

	// Fix #3: Предотвращение утечки горутины
	n.wg.Add(1)
	go func() {
		defer n.wg.Done()
		n.FindContact(nickname)
	}()
}

func (n *Node) HandleDecision(nick string, accept bool) {
	c := n.getContactByNick(nick)
	if c == nil {
		n.Log(LogLevelError, "Контакт '%s' не найден", nick)
		return
	}

	c.mu.Lock()
	isIncoming := c.State == StatePendingIncoming
	hasSession := c.sessionEstab
	pid := c.PeerID
	c.mu.Unlock()

	if !isIncoming || !hasSession {
		n.Log(LogLevelWarning, "Нет входящего запроса от %s", nick)
		return
	}

	if accept {
		if err := n.sendSessionMessage(c, MsgTypeAccept, "OK"); err != nil {
			n.Log(LogLevelError, "Ошибка отправки подтверждения: %v", err)
			return
		}
		c.mu.Lock()
		c.State = StateActive
		c.mu.Unlock()
		// Fix #6
		n.notifyContactUpdate()
		n.EnterChat(pid)
	} else {
		// Fix #4, #5: Используем helper для отправки отказа и закрытия
		n.sendTerminalMessage(c, MsgTypeDecline, "NO")
		n.Log(LogLevelSuccess, "Отклонено")
		// Fix #6
		n.notifyContactUpdate()
	}
}

func (n *Node) Disconnect(nick string) {
	c := n.getContactByNick(nick)
	if c == nil {
		n.Log(LogLevelError, "Контакт '%s' не найден", nick)
		return
	}

	c.mu.Lock()
	state := c.State
	hasStream := c.Stream != nil
	hasSession := c.sessionEstab
	isConnecting := c.Connecting
	cancelFunc := c.connectCancel
	pid := c.PeerID
	c.mu.Unlock()

	if state == StateIdle && !isConnecting && !hasStream {
		n.Log(LogLevelWarning, "Нет активного соединения с %s", nick)
		return
	}

	if cancelFunc != nil {
		cancelFunc()
	}

	n.mu.Lock()
	wasActiveChat := n.activeChat == pid
	if wasActiveChat {
		n.activeChat = ""
	}
	n.mu.Unlock()

	if wasActiveChat {
		// Fix #6
		n.notifyChatChanged("", "")
	}

	// Fix #4, #5: Централизованная логика завершения
	if hasStream && hasSession {
		var msgType MessageType
		switch state {
		case StatePendingOutgoing:
			msgType = MsgTypeCancel
		case StatePendingIncoming:
			msgType = MsgTypeDecline
		case StateActive:
			msgType = MsgTypeBye
		default:
			msgType = MsgTypeBye
		}
		// Отправляет сообщение, ждет (немного) и закрывает стрим
		n.sendTerminalMessage(c, msgType, nil)
	} else {
		n.closeStream(c)
	}

	switch state {
	case StatePendingOutgoing:
		n.Log(LogLevelSuccess, "Запрос к %s отменён", nick)
	case StatePendingIncoming:
		n.Log(LogLevelSuccess, "Входящий запрос от %s отклонён", nick)
	case StateActive:
		n.Log(LogLevelSuccess, "Чат с %s завершён", nick)
	default:
		if isConnecting {
			n.Log(LogLevelSuccess, "Подключение к %s отменено", nick)
		} else {
			n.Log(LogLevelSuccess, "Соединение с %s разорвано", nick)
		}
	}

	// Fix #6
	n.notifyContactUpdate()
}

func (n *Node) DisconnectByPeerID(pid peer.ID) {
	c := n.getContactByID(pid)
	if c == nil {
		return
	}
	c.mu.Lock()
	nick := c.Nickname
	c.mu.Unlock()
	n.Disconnect(nick)
}

func (n *Node) EnterChat(id peer.ID) {
	n.mu.Lock()
	c := n.contacts[id]
	if c == nil {
		n.mu.Unlock()
		return
	}
	n.activeChat = id
	n.mu.Unlock()

	c.mu.Lock()
	nick := c.Nickname
	c.mu.Unlock()

	// Fix #6
	n.notifyChatChanged(id.String(), nick)
	n.Log(LogLevelInfo, "ЧАТ: %s (Forward Secrecy: ON, XChaCha20)", nick)
}

func (n *Node) LeaveChat() {
	n.mu.Lock()
	id := n.activeChat
	n.activeChat = ""
	n.mu.Unlock()

	// Fix #6
	n.notifyChatChanged("", "")

	if id == "" {
		return
	}

	c := n.getContactByID(id)
	if c != nil {
		// Fix #4, #5: Terminal message
		n.sendTerminalMessage(c, MsgTypeBye, nil)
		n.Log(LogLevelSuccess, "Чат завершён")
		// Fix #6
		n.notifyContactUpdate()
	}
}

func (n *Node) Logout() {
	n.mu.Lock()
	// Копируем слайс контактов под локом (Snapshotting)
	// Это безопасно (см. пункт 7 ревью)
	contacts := make([]*Contact, 0, len(n.contacts))
	for _, c := range n.contacts {
		contacts = append(contacts, c)
	}
	oldNick := n.nickname
	n.activeChat = ""
	n.nickname = ""
	n.mu.Unlock()

	if oldNick == "" {
		n.Log(LogLevelWarning, "Вы не залогинены")
		return
	}

	for _, c := range contacts {
		// Fix #4: Использование terminal message для каждого контакта
		// Внутри проверяется наличие сессии
		n.sendTerminalMessage(c, MsgTypeBye, nil)
	}

	n.saveIdentity()

	// Fix #6
	n.notifyChatChanged("", "")
	n.notifyContactUpdate()
	n.Log(LogLevelSuccess, "Вы вышли из аккаунта")
}

func (n *Node) RemoveFriend(nick string) {
	c := n.getContactByNick(nick)
	if c == nil {
		n.Log(LogLevelError, "Контакт '%s' не найден", nick)
		return
	}

	c.mu.Lock()
	pid := c.PeerID
	c.mu.Unlock()

	// Fix #4: Отправляем Bye и закрываем
	n.sendTerminalMessage(c, MsgTypeBye, nil)

	n.mu.Lock()
	wasActiveChat := n.activeChat == pid
	if wasActiveChat {
		n.activeChat = ""
	}
	delete(n.contacts, pid)
	delete(n.nickMap, nick)
	n.mu.Unlock()

	if wasActiveChat {
		// Fix #6
		n.notifyChatChanged("", "")
	}

	n.SaveContacts()
	// Fix #6
	n.notifyContactUpdate()
	n.Log(LogLevelSuccess, "Контакт '%s' удалён", nick)
}

func (n *Node) IsLoggedIn() bool {
	n.mu.RLock()
	defer n.mu.RUnlock()
	return n.nickname != ""
}


------------------------------------------------------------
ПУТЬ: pkg -> f2f -> config.go
------------------------------------------------------------
package f2f

import (
	"time"
)

// --- Version & Protocol ---

const (
	ProtocolVersion  = "1.4.0-ratchet" // Bump version
	ProtocolID       = "/f2f-chat/1.4.0"
	RendezvousString = "f2f-chat-bin-v1"
	ContactsFile     = "contacts.dat"
	IdentityFile     = "identity.dat"
)

// --- Limits ---

const (
	HandshakeLimit = 4096
	MaxNickLength  = 32
	MaxMsgLength   = 4000
	MaxFrameSize   = 64 * 1024 * 1024
	FileChunkSize  = 256 * 1024
	MaxSkipKeys    = 500 // Сколько ключей хранить для out-of-order сообщений
)

// --- Timeouts ---

const (
	PeerLookupTimeout  = 45 * time.Second
	PresenceTimeout    = 15 * time.Second
	PresenceInterval   = 30 * time.Second
	AdvertiseDelay     = 5 * time.Second
	KeepAliveInterval  = 30 * time.Second
	AdvertiseInterval  = 1 * time.Minute
	StreamReadTimeout  = 10 * time.Minute
	HandshakeTimeout   = 10 * time.Second
	WriteTimeout       = 60 * time.Second
	BootstrapTimeout   = 15 * time.Second
	MaxTimeSkew        = 2 * time.Minute
	NewStreamTimeout   = 30 * time.Second
	ReconnectCooldown  = 3 * time.Second
	ShutdownTimeout    = 3 * time.Second
	MaxPresenceBackoff = 15 * time.Minute
	FileOfferTimeout   = 10 * time.Minute
)

// --- Ratchet KDF Info ---
// Используются для разделения контекстов HKDF
var (
	InfoRootKey  = []byte("F2F-Ratchet-Root")
	InfoChainKey = []byte("F2F-Ratchet-Chain")
	InfoMsgKey   = []byte("F2F-Ratchet-Msg")
)

// --- Limits ---

const (
	PresenceMaxWorkers  = 3
	MaxNoncesPerContact = 100
)

// --- Debug ---

var DebugMode = false


------------------------------------------------------------
ПУТЬ: pkg -> f2f -> crypto.go
------------------------------------------------------------
package f2f

import (
	"bytes"
	"crypto/hmac"
	"crypto/rand"
	"crypto/sha256"
	"encoding/binary"
	"errors"
	"fmt"
	"io"
	"time"

	"golang.org/x/crypto/chacha20poly1305"
	"golang.org/x/crypto/curve25519"
	"golang.org/x/crypto/hkdf"
)

// --- Forward Secrecy Key Generation ---

func generateEphemeralKeys() (*[32]byte, *[32]byte, error) {
	var priv, pub [32]byte
	if _, err := io.ReadFull(rand.Reader, priv[:]); err != nil {
		return nil, nil, err
	}
	// Clamp private key for X25519
	priv[0] &= 248
	priv[31] &= 127
	priv[31] |= 64

	curve25519.ScalarBaseMult(&pub, &priv)
	return &priv, &pub, nil
}

// --- Double Ratchet Implementation ---

// InitializeRatchet создает начальное состояние Ratchet из общего секрета Handshake.
// isAlice = true для инициатора (Alice), false для ответчика (Bob).
func InitializeRatchet(sharedSecret *[32]byte, bobPub *[32]byte) (*RatchetState, error) {
	rs := &RatchetState{
		SkippedMsgKeys: make(map[[36]byte]SkippedKey),
	}

	// Инициализация Root Chain из shared secret
	// В Signal обычно делается сложнее (3-way handshake), но мы адаптируем существующий 2-way.
	// Используем sharedSecret как начальный RootKey.
	rs.RootKey = *sharedSecret

	if bobPub != nil {
		// ALICE (Initiator)
		// У нас уже есть ключ Bob'a (из Handshake), и у нас есть наш Initial Key.
		// Генерируем новый Ratchet Key pair сразу.
		priv, pub, err := generateEphemeralKeys()
		if err != nil {
			return nil, err
		}
		rs.DHLocalPriv = priv
		rs.DHLocalPub = pub
		rs.DHRemotePub = bobPub

		// Alice делает первый DH шаг сразу, так как она знает ключ Боба
		shared := computeDH(rs.DHLocalPriv, rs.DHRemotePub)
		newRK, newCKs := kdfRK(&rs.RootKey, &shared)
		rs.RootKey = newRK
		rs.ChainKeyS = newCKs
		// ChainKeyR останется пустым, пока Боб не ответит
	} else {
		// BOB (Responder)
		// У нас пока нет Ratchet ключа, мы просто знаем RootKey (SharedSecret).
		// Мы сохраним Handshake ключи как "Local", но для первого шага используем логику приема.
		// В текущей реализации (f2f handshake) Боб сгенерировал EphemeralPub в handshake.
		// Это и будет его "текущий" Ratchet Key.
		// Примечание: Это упрощение. В идеале нужен новый обмен.
		// Но мы просто инициализируем пару пустыми значениями и будем ждать первого заголовка от Алисы.

		// Боб сгенерирует ключи при первом Ratchet step
		priv, pub, err := generateEphemeralKeys()
		if err != nil {
			return nil, err
		}
		rs.DHLocalPriv = priv
		rs.DHLocalPub = pub
		// RemotePub пока неизвестен (в контексте Ratchet), он придет в заголовке
	}

	return rs, nil
}

// RatchetEncrypt шифрует сообщение, продвигая Symmetric Chain.
// Возвращает: Header (plaintext), Ciphertext, Error
func (n *Node) RatchetEncrypt(rs *RatchetState, plaintext []byte) ([]byte, []byte, error) {
	// 1. Продвигаем Sending Chain
	newCKs, msgKey := kdfCK(&rs.ChainKeyS)
	rs.ChainKeyS = newCKs

	// 2. Формируем заголовок
	header := RatchetHeader{
		PublicKey: *rs.DHLocalPub,
		PN:        rs.PN,
		N:         rs.Ns,
	}
	headerBytes := header.Marshal()

	// 3. Шифруем (AEAD с header как associated data)
	// XChaCha20-Poly1305 требует nonce 24 байта.
	// В Signal nonce выводится из KDF, но XChaCha random nonce безопаснее.
	ciphertext, err := n.encryptXChaChaAD(plaintext, &msgKey, headerBytes)
	if err != nil {
		return nil, nil, err
	}

	rs.Ns++
	return headerBytes, ciphertext, nil
}

// RatchetDecrypt дешифрует сообщение, обрабатывая пропуски и DH steps.
func (n *Node) RatchetDecrypt(rs *RatchetState, headerBytes, ciphertext []byte) ([]byte, error) {
	var header RatchetHeader
	if err := header.Unmarshal(headerBytes); err != nil {
		return nil, fmt.Errorf("bad header: %v", err)
	}

	// 1. Попытка дешифровать сохраненными (пропущенными) ключами
	if plaintext, ok := n.trySkippedKeys(rs, &header, ciphertext, headerBytes); ok {
		return plaintext, nil
	}

	// 2. Если пришел новый DH ключ (Ratchet Step)
	if header.PublicKey != *rs.DHRemotePub {
		// Проверяем, не слишком ли далеко ушел шаг (Anti-DoS)
		// Для упрощения пропускаем строгую проверку лимита шагов, но в продакшене нужна.

		// Сохраняем пропущенные ключи из *текущей* приемной цепочки
		if err := n.skipMessageKeys(rs, header.PN); err != nil {
			return nil, fmt.Errorf("skip keys error: %v", err)
		}

		// Выполняем DH Ratchet Step
		if err := n.dhRatchetStep(rs, &header.PublicKey); err != nil {
			return nil, fmt.Errorf("dh ratchet error: %v", err)
		}
	}

	// 3. Сохраняем пропущенные ключи в *новой* цепочке (если N перескочил)
	if err := n.skipMessageKeys(rs, header.N); err != nil {
		return nil, fmt.Errorf("skip keys current chain error: %v", err)
	}

	// 4. Продвигаем Receiving Chain и получаем Message Key
	newCKr, msgKey := kdfCK(&rs.ChainKeyR)
	rs.ChainKeyR = newCKr
	rs.Nr++

	// 5. Дешифруем
	plaintext, err := n.decryptXChaChaAD(ciphertext, &msgKey, headerBytes)
	if err != nil {
		return nil, fmt.Errorf("decrypt failed: %v", err)
	}

	return plaintext, nil
}

func (n *Node) trySkippedKeys(rs *RatchetState, h *RatchetHeader, ciphertext, ad []byte) ([]byte, bool) {
	// Ключ карты: PubKey + N
	var mapKey [36]byte
	copy(mapKey[0:32], h.PublicKey[:])
	binary.BigEndian.PutUint32(mapKey[32:36], h.N)

	if val, exists := rs.SkippedMsgKeys[mapKey]; exists {
		plaintext, err := n.decryptXChaChaAD(ciphertext, &val.Key, ad)
		if err == nil {
			delete(rs.SkippedMsgKeys, mapKey)
			return plaintext, true
		}
	}
	return nil, false
}

func (n *Node) skipMessageKeys(rs *RatchetState, until uint32) error {
	if rs.Nr+uint32(MaxSkipKeys) < until {
		return errors.New("too many skipped messages")
	}

	// Если ChainKeyR не инициализирован (первый шаг), пропускать нечего
	var empty [32]byte
	if rs.ChainKeyR == empty {
		return nil
	}

	for rs.Nr < until {
		newCKr, msgKey := kdfCK(&rs.ChainKeyR)
		rs.ChainKeyR = newCKr

		var mapKey [36]byte
		copy(mapKey[0:32], rs.DHRemotePub[:])
		binary.BigEndian.PutUint32(mapKey[32:36], rs.Nr)

		rs.SkippedMsgKeys[mapKey] = SkippedKey{
			Key:       msgKey,
			Timestamp: time.Now(),
		}
		rs.Nr++
	}
	return nil
}

func (n *Node) dhRatchetStep(rs *RatchetState, remotePub *[32]byte) error {
	rs.PN = rs.Ns
	rs.Ns = 0
	rs.Nr = 0
	rs.DHRemotePub = remotePub

	// Root KDF 1: R_k + DH(Local, Remote) -> New R_k, ChainKeyR
	sharedReceive := computeDH(rs.DHLocalPriv, remotePub)
	rs.RootKey, rs.ChainKeyR = kdfRK(&rs.RootKey, &sharedReceive)

	// Генерируем новый ключ для отправки
	priv, pub, err := generateEphemeralKeys()
	if err != nil {
		return err
	}
	rs.DHLocalPriv = priv
	rs.DHLocalPub = pub

	// Root KDF 2: R_k + DH(NewLocal, Remote) -> New R_k, ChainKeyS
	sharedSend := computeDH(rs.DHLocalPriv, remotePub)
	rs.RootKey, rs.ChainKeyS = kdfRK(&rs.RootKey, &sharedSend)

	return nil
}

// --- KDF Helpers ---

// computeDH: X25519(priv, pub)
func computeDH(priv, pub *[32]byte) [32]byte {
	var shared [32]byte
	curve25519.ScalarMult(&shared, priv, pub)
	return shared
}

// kdfRK: HKDF(root_key, dh_out) -> (root_key, chain_key)
func kdfRK(rootKey, dhOut *[32]byte) ([32]byte, [32]byte) {
	// Salt = RootKey, IKM = DH Output
	hkdfReader := hkdf.New(sha256.New, dhOut[:], rootKey[:], InfoRootKey)

	var out [64]byte
	io.ReadFull(hkdfReader, out[:])

	var newRoot [32]byte
	var newChain [32]byte
	copy(newRoot[:], out[0:32])
	copy(newChain[:], out[32:64])

	return newRoot, newChain
}

// kdfCK: HMAC(chain_key) -> (chain_key, msg_key)
func kdfCK(chainKey *[32]byte) ([32]byte, [32]byte) {
	// HMAC-SHA256
	// MsgKey = HMAC(ChainKey, "1")
	// NextChainKey = HMAC(ChainKey, "2")

	h := hmac.New(sha256.New, chainKey[:])
	h.Write([]byte{0x01})
	res1 := h.Sum(nil) // Используем часть как ключ

	h.Reset()
	h.Write([]byte{0x02})
	res2 := h.Sum(nil)

	// KDF обычно требует 32 байта для ключа
	// Используем HKDF expander или просто SHA256 output,
	// но HMAC-SHA256 уже дает 32 байта, что подходит.

	// Чтобы строго соответствовать Signal spec, там используются константы 0x01, 0x02
	// и HMAC как KDF.
	// Мы дополнительно прогоним через HKDF-Expand для чистоты изоляции (InfoMsgKey).

	// Message Key Derivation
	mkReader := hkdf.Expand(sha256.New, res1, InfoMsgKey)
	var msgKey [32]byte
	io.ReadFull(mkReader, msgKey[:])

	// Chain Key Derivation
	ckReader := hkdf.Expand(sha256.New, res2, InfoChainKey)
	var nextChain [32]byte
	io.ReadFull(ckReader, nextChain[:])

	return nextChain, msgKey
}

// --- XChaCha20-Poly1305 with AD ---

func (n *Node) encryptXChaChaAD(plaintext []byte, key *[32]byte, ad []byte) ([]byte, error) {
	aead, err := chacha20poly1305.NewX(key[:])
	if err != nil {
		return nil, err
	}

	nonce := make([]byte, aead.NonceSize(), aead.NonceSize()+len(plaintext)+aead.Overhead())
	if _, err := io.ReadFull(rand.Reader, nonce); err != nil {
		return nil, err
	}

	return aead.Seal(nonce, nonce, plaintext, ad), nil
}

func (n *Node) decryptXChaChaAD(ciphertext []byte, key *[32]byte, ad []byte) ([]byte, error) {
	aead, err := chacha20poly1305.NewX(key[:])
	if err != nil {
		return nil, err
	}

	if len(ciphertext) < aead.NonceSize() {
		return nil, errors.New("ciphertext too short")
	}

	nonce, encrypted := ciphertext[:aead.NonceSize()], ciphertext[aead.NonceSize():]
	return aead.Open(nil, nonce, encrypted, ad)
}

// --- Legacy & Helpers ---

// createHandshakeBytes creates signed handshake payload
func (n *Node) createHandshakeBytes(ephPub *[32]byte) ([]byte, error) {
	privKey := n.host.Peerstore().PrivKey(n.host.ID())
	var nonce int64

	if err := binary.Read(rand.Reader, binary.LittleEndian, &nonce); err != nil {
		return nil, err
	}

	payload := HandshakePayload{
		Version:      ProtocolVersion,
		Timestamp:    time.Now().UnixNano(),
		Nonce:        nonce,
		NaClPubKey:   n.naclPublic[:],
		EphemeralPub: ephPub[:],
	}

	buf := new(bytes.Buffer)
	buf.WriteString(payload.Version)
	binary.Write(buf, binary.BigEndian, payload.Timestamp)
	binary.Write(buf, binary.BigEndian, payload.Nonce)
	buf.Write(payload.NaClPubKey)
	buf.Write(payload.EphemeralPub)

	sig, err := privKey.Sign(buf.Bytes())
	if err != nil {
		return nil, err
	}
	payload.Signature = sig

	return payload.Marshal(), nil
}

func (n *Node) verifyHandshake(c *Contact, data []byte) (*[32]byte, error) {
	if len(data) > HandshakeLimit {
		return nil, errors.New("too large")
	}

	var payload HandshakePayload
	if err := payload.Unmarshal(data); err != nil {
		return nil, fmt.Errorf("decode handshake: %w", err)
	}

	// Разрешаем старые версии, если нужно, но лучше строгий чек
	if payload.Version != ProtocolVersion {
		// Log warning?
	}

	if len(payload.EphemeralPub) != 32 {
		return nil, errors.New("bad eph key")
	}

	// Check timestamp
	now := time.Now()
	ts := time.Unix(0, payload.Timestamp)
	if now.Sub(ts) > MaxTimeSkew || ts.Sub(now) > MaxTimeSkew {
		return nil, errors.New("time skew")
	}

	// Replay protection
	c.mu.Lock()
	if c.SeenNonces == nil {
		c.SeenNonces = make(map[int64]time.Time)
	}
	for k, t := range c.SeenNonces {
		if time.Since(t) > MaxTimeSkew {
			delete(c.SeenNonces, k)
		}
	}
	if len(c.SeenNonces) >= MaxNoncesPerContact {
		c.mu.Unlock()
		return nil, errors.New("flood")
	}
	if _, exists := c.SeenNonces[payload.Nonce]; exists {
		c.mu.Unlock()
		return nil, errors.New("replay")
	}
	c.SeenNonces[payload.Nonce] = time.Now()
	c.mu.Unlock()

	// Verify signature
	remotePub := n.host.Peerstore().PubKey(c.PeerID)
	if remotePub == nil {
		return nil, errors.New("no key")
	}

	buf := new(bytes.Buffer)
	buf.WriteString(payload.Version)
	binary.Write(buf, binary.BigEndian, payload.Timestamp)
	binary.Write(buf, binary.BigEndian, payload.Nonce)
	buf.Write(payload.NaClPubKey)
	buf.Write(payload.EphemeralPub)

	ok, _ := remotePub.Verify(buf.Bytes(), payload.Signature)
	if !ok {
		return nil, errors.New("bad sig")
	}

	var recKey [32]byte
	copy(recKey[:], payload.NaClPubKey)
	if recKey != c.PublicKey {
		return nil, errors.New("key mismatch")
	}

	var ephPub [32]byte
	copy(ephPub[:], payload.EphemeralPub)
	return &ephPub, nil
}

// deriveSessionKey используется ТОЛЬКО для начального handshake, чтобы получить RootKey
func deriveSessionKey(localPriv, localPub, remotePub *[32]byte) (*[32]byte, error) {
	var shared [32]byte
	curve25519.ScalarMult(&shared, localPriv, remotePub)

	var saltBuf bytes.Buffer
	saltBuf.WriteString("f2f-init-v1:")
	if bytes.Compare(localPub[:], remotePub[:]) < 0 {
		saltBuf.Write(localPub[:])
		saltBuf.Write(remotePub[:])
	} else {
		saltBuf.Write(remotePub[:])
		saltBuf.Write(localPub[:])
	}

	hkdfReader := hkdf.New(sha256.New, shared[:], saltBuf.Bytes(), []byte("session-root-deriv"))
	var sessionKey [32]byte
	if _, err := io.ReadFull(hkdfReader, sessionKey[:]); err != nil {
		return nil, err
	}

	// Zero shared
	for i := range shared {
		shared[i] = 0
	}
	return &sessionKey, nil
}

func ComputeFingerprint(pubKey []byte) string {
	hash := sha256.Sum256(pubKey)
	hex := fmt.Sprintf("%X", hash[:8])
	return fmt.Sprintf("%s-%s-%s-%s", hex[0:4], hex[4:8], hex[8:12], hex[12:16])
}


------------------------------------------------------------
ПУТЬ: pkg -> f2f -> encryption.go
------------------------------------------------------------
package f2f

import (
	"crypto/rand"
	"errors"
	"fmt"
	"io"
	"os"
	"path/filepath"

	"golang.org/x/crypto/argon2"
	"golang.org/x/crypto/chacha20poly1305"
)

// Параметры Argon2id
const (
	argonTime    = 3
	argonMemory  = 64 * 1024 // 64 MB
	argonThreads = 4
	argonKeyLen  = 32
	saltLen      = 16
)

var ErrWrongPassword = errors.New("wrong password or corrupted data")
var ErrNoPassword = errors.New("password required")

// deriveKey генерирует ключ из пароля используя Argon2id
func deriveKey(password string, salt []byte) []byte {
	return argon2.IDKey([]byte(password), salt, argonTime, argonMemory, argonThreads, argonKeyLen)
}

// encryptData шифрует данные с паролем используя XChaCha20-Poly1305
// Формат: salt (16) + nonce (24) + ciphertext
func encryptData(plaintext []byte, password string) ([]byte, error) {
	if password == "" {
		return nil, ErrNoPassword
	}

	salt := make([]byte, saltLen)
	if _, err := io.ReadFull(rand.Reader, salt); err != nil {
		return nil, fmt.Errorf("generate salt: %w", err)
	}

	key := deriveKey(password, salt)

	// XChaCha20-Poly1305
	aead, err := chacha20poly1305.NewX(key)
	if err != nil {
		return nil, err
	}

	nonce := make([]byte, aead.NonceSize(), aead.NonceSize()+len(plaintext)+aead.Overhead())
	if _, err := io.ReadFull(rand.Reader, nonce); err != nil {
		return nil, fmt.Errorf("generate nonce: %w", err)
	}

	// Seal: добавляет ciphertext к nonce
	ciphertext := aead.Seal(nonce, nonce, plaintext, nil)

	// Result: salt + (nonce + ciphertext)
	result := make([]byte, saltLen+len(ciphertext))
	copy(result[:saltLen], salt)
	copy(result[saltLen:], ciphertext)

	return result, nil
}

// decryptData дешифрует данные
func decryptData(encrypted []byte, password string) ([]byte, error) {
	if password == "" {
		return nil, ErrNoPassword
	}

	// Проверка минимальной длины: Salt + Nonce + Tag
	if len(encrypted) < saltLen+24+16 {
		return nil, ErrWrongPassword
	}

	salt := encrypted[:saltLen]
	dataWithNonce := encrypted[saltLen:]

	key := deriveKey(password, salt)

	aead, err := chacha20poly1305.NewX(key)
	if err != nil {
		return nil, err
	}

	if len(dataWithNonce) < aead.NonceSize() {
		return nil, ErrWrongPassword
	}

	nonce := dataWithNonce[:aead.NonceSize()]
	ciphertext := dataWithNonce[aead.NonceSize():]

	plaintext, err := aead.Open(nil, nonce, ciphertext, nil)
	if err != nil {
		return nil, ErrWrongPassword
	}

	return plaintext, nil
}

// writeAtomic сохраняет данные атомарно: write -> sync -> close -> rename
func writeAtomic(filename string, data []byte) error {
	dir := filepath.Dir(filename)
	// Создаем временный файл в той же директории, чтобы Rename был атомарным
	tmpFile, err := os.CreateTemp(dir, "f2f-atomic-*")
	if err != nil {
		return fmt.Errorf("create temp file: %w", err)
	}
	tmpPath := tmpFile.Name()

	// Очистка в случае ошибки
	closed := false
	defer func() {
		if !closed {
			tmpFile.Close()
			os.Remove(tmpPath)
		}
	}()

	if _, err := tmpFile.Write(data); err != nil {
		return fmt.Errorf("write temp file: %w", err)
	}

	// Принудительный сброс на диск
	if err := tmpFile.Sync(); err != nil {
		return fmt.Errorf("sync temp file: %w", err)
	}

	if err := tmpFile.Close(); err != nil {
		return fmt.Errorf("close temp file: %w", err)
	}
	closed = true

	// Атомарная замена
	if err := os.Rename(tmpPath, filename); err != nil {
		// Если Rename не удался, удаляем временный файл
		os.Remove(tmpPath)
		return fmt.Errorf("atomic rename: %w", err)
	}

	return nil
}

// saveEncrypted сохраняет данные в файл. Данные уже должны быть сериализованы в []byte.
func saveEncrypted(filename string, data []byte, password string) error {
	encrypted, err := encryptData(data, password)
	if err != nil {
		return err
	}

	return writeAtomic(filename, encrypted)
}

// loadEncrypted загружает и дешифрует данные из файла. Возвращает []byte, который caller должен десериализовать.
func loadEncrypted(filename string, password string) ([]byte, error) {
	encrypted, err := os.ReadFile(filename)
	if err != nil {
		return nil, err
	}

	plaintext, err := decryptData(encrypted, password)
	if err != nil {
		return nil, err
	}

	return plaintext, nil
}

func IdentityExists() bool {
	_, err := os.Stat(IdentityFile)
	return err == nil
}

func ContactsExist() bool {
	_, err := os.Stat(ContactsFile)
	return err == nil
}

func ValidatePassword(password string) error {
	if !IdentityExists() {
		return nil
	}
	if password == "" {
		return ErrNoPassword
	}
	// Пытаемся расшифровать Identity, чтобы проверить пароль
	_, err := loadEncrypted(IdentityFile, password)
	return err
}

func IsNewUser() bool {
	return !IdentityExists()
}

func ChangePassword(oldPassword, newPassword string) error {
	if newPassword == "" {
		return ErrNoPassword
	}
	if err := ValidatePassword(oldPassword); err != nil {
		return err
	}

	// 1. Re-encrypt Identity
	if IdentityExists() {
		rawID, err := loadEncrypted(IdentityFile, oldPassword)
		if err != nil {
			return err
		}
		if err := saveEncrypted(IdentityFile, rawID, newPassword); err != nil {
			return err
		}
	}

	// 2. Re-encrypt Contacts
	if ContactsExist() {
		rawContacts, err := loadEncrypted(ContactsFile, oldPassword)
		if err != nil {
			return err
		}
		if err := saveEncrypted(ContactsFile, rawContacts, newPassword); err != nil {
			return err
		}
	}

	return nil
}


------------------------------------------------------------
ПУТЬ: pkg -> f2f -> file_transfer.go
------------------------------------------------------------
package f2f

import (
	"crypto/rand"
	"crypto/sha256"
	"encoding/hex"
	"errors"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"time"

	"github.com/libp2p/go-libp2p/core/peer"
)

func generateFileID() ([16]byte, string) {
	var id [16]byte
	rand.Read(id[:])
	return id, hex.EncodeToString(id[:])
}

func parseFileID(hexStr string) ([16]byte, error) {
	var id [16]byte
	b, err := hex.DecodeString(hexStr)
	if err != nil || len(b) != 16 {
		return id, errors.New("invalid file ID")
	}
	copy(id[:], b)
	return id, nil
}

func (n *Node) SendFile(peerID peer.ID, filePath string) error {
	c := n.getContactByID(peerID)
	if c == nil {
		return errors.New("contact not found")
	}

	c.mu.Lock()
	state := c.State
	hasPending := c.PendingFile != nil
	c.mu.Unlock()

	if state != StateActive {
		return errors.New("chat not active")
	}

	if hasPending {
		return errors.New("already have pending file transfer")
	}

	info, err := os.Stat(filePath)
	if err != nil {
		return fmt.Errorf("cannot access file: %w", err)
	}
	if info.IsDir() {
		return errors.New("cannot send directory")
	}
	f, err := os.Open(filePath)
	if err != nil {
		return fmt.Errorf("cannot read file: %w", err)
	}
	f.Close()

	fileSize := info.Size()
	fileName := filepath.Base(filePath)
	fileIDBinary, fileIDHex := generateFileID()

	transfer := &FileTransfer{
		ID:         fileIDHex,
		IDBinary:   fileIDBinary,
		Name:       fileName,
		Size:       fileSize,
		FilePath:   filePath,
		IsOutgoing: true,
		CreatedAt:  time.Now(),
	}

	c.mu.Lock()
	c.PendingFile = transfer
	c.mu.Unlock()

	offer := FileOffer{
		ID:   fileIDHex,
		Name: fileName,
		Size: fileSize,
	}

	if err := n.sendSessionMessage(c, MsgTypeFileOffer, offer.Marshal()); err != nil {
		c.mu.Lock()
		c.PendingFile = nil
		c.mu.Unlock()
		return err
	}

	n.Log(LogLevelInfo, "Предложен файл '%s' (%s), ожидание ответа...", fileName, formatSize(fileSize))
	return nil
}

func (n *Node) AcceptFile(nick string) error {
	c := n.getContactByNick(nick)
	if c == nil {
		activeID := n.GetActiveChat()
		if activeID == "" {
			return errors.New("no active chat")
		}
		c = n.getContactByID(activeID)
		if c == nil {
			return errors.New("contact not found")
		}
	}

	c.mu.Lock()
	pending := c.PendingFile
	if pending == nil {
		c.mu.Unlock()
		return errors.New("no pending file offer")
	}
	if pending.IsOutgoing {
		c.mu.Unlock()
		return errors.New("this is outgoing transfer")
	}
	fileID := pending.ID
	fileName := pending.Name

	tempPath := fileName + ".tmp." + fileID[:8]
	tempFile, err := os.Create(tempPath)
	if err != nil {
		c.mu.Unlock()
		return fmt.Errorf("cannot create temp file: %w", err)
	}

	pending.TempFile = tempFile
	pending.TempPath = tempPath
	pending.Hasher = sha256.New()
	c.mu.Unlock()

	resp := FileResponse{ID: fileID}

	if err := n.sendSessionMessage(c, MsgTypeFileAccept, resp.Marshal()); err != nil {
		tempFile.Close()
		os.Remove(tempPath)
		c.mu.Lock()
		c.PendingFile = nil
		c.mu.Unlock()
		return err
	}

	n.Log(LogLevelSuccess, "Принят файл '%s' (%s), ожидание данных...", fileName, formatSize(pending.Size))
	return nil
}

func (n *Node) DeclineFile(nick string) error {
	c := n.getContactByNick(nick)
	if c == nil {
		activeID := n.GetActiveChat()
		if activeID == "" {
			return errors.New("no active chat")
		}
		c = n.getContactByID(activeID)
		if c == nil {
			return errors.New("contact not found")
		}
	}

	c.mu.Lock()
	pending := c.PendingFile
	if pending == nil {
		c.mu.Unlock()
		return errors.New("no pending file transfer")
	}
	fileID := pending.ID
	fileName := pending.Name
	isOutgoing := pending.IsOutgoing

	if pending.TempFile != nil {
		pending.TempFile.Close()
		os.Remove(pending.TempPath)
	}
	c.PendingFile = nil
	c.mu.Unlock()

	resp := FileResponse{ID: fileID}
	payload := resp.Marshal()

	msgType := MsgTypeFileDecline
	if isOutgoing {
		msgType = MsgTypeFileCancel
	}

	n.sendSessionMessage(c, msgType, payload)

	if isOutgoing {
		n.Log(LogLevelInfo, "Отправка файла '%s' отменена", fileName)
	} else {
		n.Log(LogLevelInfo, "Файл '%s' отклонён", fileName)
	}
	return nil
}

func (n *Node) HasPendingFile() (bool, bool, string, int64) {
	activeID := n.GetActiveChat()
	if activeID == "" {
		return false, false, "", 0
	}
	c := n.getContactByID(activeID)
	if c == nil {
		return false, false, "", 0
	}

	c.mu.Lock()
	defer c.mu.Unlock()

	if c.PendingFile == nil {
		return false, false, "", 0
	}
	return true, c.PendingFile.IsOutgoing, c.PendingFile.Name, c.PendingFile.Size
}

func (n *Node) sendFileChunks(c *Contact, transfer *FileTransfer) {
	c.mu.Lock()
	// FIX: Используем Ratchet вместо sessionKey
	hasRatchet := c.Ratchet != nil
	nick := c.Nickname
	pid := c.PeerID
	c.mu.Unlock()

	if !hasRatchet {
		n.notifyFileComplete(pid.String(), nick, transfer.Name, false, "no session")
		c.mu.Lock()
		c.PendingFile = nil
		c.mu.Unlock()
		return
	}

	file, err := os.Open(transfer.FilePath)
	if err != nil {
		n.notifyFileComplete(pid.String(), nick, transfer.Name, false, "open error: "+err.Error())
		c.mu.Lock()
		c.PendingFile = nil
		c.mu.Unlock()
		return
	}
	defer file.Close()

	hasher := sha256.New()
	totalChunks := int((transfer.Size + FileChunkSize - 1) / FileChunkSize)
	transfer.TotalChunks = totalChunks

	n.Log(LogLevelInfo, "Отправка '%s' (%d чанков, Double Ratchet)...", transfer.Name, totalChunks)

	chunkBuffer := make([]byte, FileChunkSize)

	for i := 0; i < totalChunks; i++ {
		c.mu.Lock()
		if c.PendingFile == nil || c.PendingFile.Cancelled {
			c.mu.Unlock()
			return
		}
		c.mu.Unlock()

		bytesRead, err := file.Read(chunkBuffer)
		if err != nil && err != io.EOF {
			n.notifyFileComplete(pid.String(), nick, transfer.Name, false, "read error: "+err.Error())
			c.mu.Lock()
			c.PendingFile = nil
			c.mu.Unlock()
			return
		}

		if bytesRead == 0 {
			break
		}

		chunkData := chunkBuffer[:bytesRead]
		hasher.Write(chunkData)

		// FIX: Убрали аргумент sessionKey
		if err := n.sendBinaryChunk(c, transfer.IDBinary, uint32(i), uint32(totalChunks), chunkData); err != nil {
			n.notifyFileComplete(pid.String(), nick, transfer.Name, false, "send error")
			c.mu.Lock()
			c.PendingFile = nil
			c.mu.Unlock()
			return
		}

		progress := float64(i+1) / float64(totalChunks)
		n.notifyFileProgress(pid.String(), nick, transfer.Name, progress, true)
	}

	hashHex := hex.EncodeToString(hasher.Sum(nil))
	done := FileDone{
		ID:   transfer.ID,
		Hash: hashHex,
	}

	n.sendSessionMessage(c, MsgTypeFileDone, done.Marshal())

	c.mu.Lock()
	c.PendingFile = nil
	c.mu.Unlock()

	n.notifyFileComplete(pid.String(), nick, transfer.Name, true, "sent")
	n.Log(LogLevelSuccess, "Файл '%s' отправлен!", transfer.Name)
}

// FIX: Новая сигнатура, принимает расшифрованный plaintext
func (n *Node) processBinaryChunk(c *Contact, plaintext []byte) {
	// Дешифровка уже выполнена в readLoop через RatchetDecrypt
	if len(plaintext) < BinaryChunkHeaderSize {
		return
	}

	// Читаем заголовок прямо из plaintext
	// [FileID 16] [Index 4] [Total 4] [Data...]
	var fileID [16]byte
	copy(fileID[:], plaintext[0:16])
	// Используем encoding/binary из пакета binary (нужно проверить импорты, но в этом файле он не импортирован)
	// Добавим ручное чтение BigEndian, так как binary не импортирован в оригинале,
	// но лучше добавить import "encoding/binary" в начало файла.
	// (Я добавил "encoding/binary" в импорты types.go, но не здесь. Здесь нет import "encoding/binary")
	// Предполагаем, что нужно добавить импорт. Для надежности реализуем тут.

	// Helper for uint32
	beUint32 := func(b []byte) uint32 {
		return uint32(b[3]) | uint32(b[2])<<8 | uint32(b[1])<<16 | uint32(b[0])<<24
	}

	index := beUint32(plaintext[16:20])
	total := beUint32(plaintext[20:24])
	data := plaintext[24:]

	c.mu.Lock()
	pending := c.PendingFile
	if pending == nil || pending.IDBinary != fileID || pending.IsOutgoing {
		c.mu.Unlock()
		return
	}

	if pending.TempFile == nil {
		c.mu.Unlock()
		return
	}

	newSize := pending.Received + int64(len(data))
	if newSize > pending.Size {
		c.mu.Unlock()
		n.Log(LogLevelError, "Ошибка: overflow")
		c.mu.Lock()
		if pending.TempFile != nil {
			pending.TempFile.Close()
			os.Remove(pending.TempPath)
		}
		c.PendingFile = nil
		c.mu.Unlock()
		n.notifyFileComplete(c.PeerID.String(), c.Nickname, pending.Name, false, "size overflow")
		return
	}

	_, err := pending.TempFile.Write(data)
	if err != nil {
		c.mu.Unlock()
		n.Log(LogLevelError, "Ошибка записи: %v", err)
		return
	}

	if pending.Hasher != nil {
		pending.Hasher.Write(data)
	}

	pending.Received = newSize
	pending.ChunksRecv = int(index) + 1
	pending.TotalChunks = int(total)

	progress := float64(pending.Received) / float64(pending.Size)
	fileName := pending.Name
	nick := c.Nickname
	pid := c.PeerID
	c.mu.Unlock()

	n.notifyFileProgress(pid.String(), nick, fileName, progress, false)
}

func (n *Node) processFileOffer(c *Contact, payload []byte) {
	var offer FileOffer
	if err := offer.Unmarshal(payload); err != nil {
		return
	}

	fileIDBinary, err := parseFileID(offer.ID)
	if err != nil {
		return
	}

	c.mu.Lock()
	if c.PendingFile != nil {
		c.mu.Unlock()
		resp := FileResponse{ID: offer.ID}
		n.sendSessionMessage(c, MsgTypeFileDecline, resp.Marshal())
		n.Log(LogLevelWarning, "Автоотклонён файл '%s' - занято", offer.Name)
		return
	}

	nick := c.Nickname
	pid := c.PeerID
	safeName := filepath.Base(offer.Name)

	c.PendingFile = &FileTransfer{
		ID:         offer.ID,
		IDBinary:   fileIDBinary,
		Name:       safeName,
		Size:       offer.Size,
		IsOutgoing: false,
		CreatedAt:  time.Now(),
	}
	c.mu.Unlock()

	n.notifyFileOffer(pid.String(), nick, safeName, offer.Size)
}

func (n *Node) processFileAccept(c *Contact, payload []byte) {
	var resp FileResponse
	if err := resp.Unmarshal(payload); err != nil {
		return
	}

	c.mu.Lock()
	pending := c.PendingFile
	if pending == nil || pending.ID != resp.ID || !pending.IsOutgoing {
		c.mu.Unlock()
		return
	}
	c.mu.Unlock()

	go n.sendFileChunks(c, pending)
}

func (n *Node) processFileDecline(c *Contact, payload []byte) {
	var resp FileResponse
	if err := resp.Unmarshal(payload); err != nil {
		return
	}

	c.mu.Lock()
	pending := c.PendingFile
	if pending == nil || pending.ID != resp.ID {
		c.mu.Unlock()
		return
	}
	fileName := pending.Name
	nick := c.Nickname
	pid := c.PeerID
	c.PendingFile = nil
	c.mu.Unlock()

	n.notifyFileComplete(pid.String(), nick, fileName, false, "declined")
	n.Log(LogLevelWarning, "%s отклонил файл '%s'", nick, fileName)
}

func (n *Node) processFileCancel(c *Contact, payload []byte) {
	var resp FileResponse
	if err := resp.Unmarshal(payload); err != nil {
		return
	}

	c.mu.Lock()
	pending := c.PendingFile
	if pending == nil || pending.ID != resp.ID {
		c.mu.Unlock()
		return
	}
	fileName := pending.Name
	nick := c.Nickname
	pid := c.PeerID
	pending.Cancelled = true

	if pending.TempFile != nil {
		pending.TempFile.Close()
		os.Remove(pending.TempPath)
	}
	c.PendingFile = nil
	c.mu.Unlock()

	n.notifyFileComplete(pid.String(), nick, fileName, false, "cancelled")
	n.Log(LogLevelInfo, "%s отменил передачу '%s'", nick, fileName)
}

func (n *Node) processFileDone(c *Contact, payload []byte) {
	var done FileDone
	if err := done.Unmarshal(payload); err != nil {
		return
	}

	c.mu.Lock()
	pending := c.PendingFile
	if pending == nil || pending.ID != done.ID || pending.IsOutgoing {
		c.mu.Unlock()
		return
	}

	fileName := pending.Name
	tempPath := pending.TempPath
	expectedHash := done.Hash
	nick := c.Nickname
	pid := c.PeerID
	var actualHashHex string

	if pending.Hasher != nil {
		actualHashHex = hex.EncodeToString(pending.Hasher.Sum(nil))
	}

	if pending.TempFile != nil {
		pending.TempFile.Close()
	}

	c.PendingFile = nil
	c.mu.Unlock()

	if actualHashHex != expectedHash {
		os.Remove(tempPath)
		n.notifyFileComplete(pid.String(), nick, fileName, false, "hash mismatch")
		n.Log(LogLevelError, "Файл '%s' повреждён", fileName)
		return
	}

	savePath := fileName
	if _, err := os.Stat(savePath); err == nil {
		ext := filepath.Ext(fileName)
		base := fileName[:len(fileName)-len(ext)]
		savePath = fmt.Sprintf("%s_%s%s", base, time.Now().Format("150405"), ext)
	}

	if err := os.Rename(tempPath, savePath); err != nil {
		if err := copyFile(tempPath, savePath); err != nil {
			os.Remove(tempPath)
			n.notifyFileComplete(pid.String(), nick, fileName, false, "save error")
			return
		}
		os.Remove(tempPath)
	}

	info, _ := os.Stat(savePath)
	savedSize := info.Size()

	n.notifyFileReceived(pid.String(), nick, fileName, savePath, savedSize)
	n.Log(LogLevelSuccess, "Файл '%s' сохранён как '%s' (%s)", fileName, savePath, formatSize(savedSize))
}

func copyFile(src, dst string) error {
	sourceFile, err := os.Open(src)
	if err != nil {
		return err
	}
	defer sourceFile.Close()

	destFile, err := os.Create(dst)
	if err != nil {
		return err
	}
	defer destFile.Close()

	_, err = io.Copy(destFile, sourceFile)
	return err
}

func formatSize(bytes int64) string {
	const (
		KB = 1024
		MB = 1024 * KB
		GB = 1024 * MB
	)
	switch {
	case bytes >= GB:
		return fmt.Sprintf("%.2f GB", float64(bytes)/GB)
	case bytes >= MB:
		return fmt.Sprintf("%.2f MB", float64(bytes)/MB)
	case bytes >= KB:
		return fmt.Sprintf("%.2f KB", float64(bytes)/KB)
	default:
		return fmt.Sprintf("%d B", bytes)
	}
}


------------------------------------------------------------
ПУТЬ: pkg -> f2f -> identity.go
------------------------------------------------------------
package f2f

import (
	"context"
	"crypto/rand"
	"time"

	"github.com/libp2p/go-libp2p"
	dht "github.com/libp2p/go-libp2p-kad-dht"
	"github.com/libp2p/go-libp2p/core/crypto"
	"github.com/libp2p/go-libp2p/core/peer"
	"github.com/libp2p/go-libp2p/p2p/discovery/routing"
	"github.com/libp2p/go-libp2p/p2p/host/autorelay"
	"golang.org/x/crypto/nacl/box"
)

func loadOrInitIdentity(password string) (crypto.PrivKey, *[32]byte, *[32]byte, string, error) {
	if IdentityExists() {
		if password == "" {
			return nil, nil, nil, "", ErrNoPassword
		}

		rawBytes, err := loadEncrypted(IdentityFile, password)
		if err != nil {
			return nil, nil, nil, "", err
		}

		var id LocalIdentity
		if err := id.Unmarshal(rawBytes); err != nil {
			return nil, nil, nil, "", err
		}

		privKey, err := crypto.UnmarshalPrivateKey(id.LibP2PPriv)
		if err != nil {
			return nil, nil, nil, "", err
		}

		var naclPub, naclPriv [32]byte
		copy(naclPub[:], id.NaClPub)
		copy(naclPriv[:], id.NaClPriv)

		return privKey, &naclPub, &naclPriv, id.Nickname, nil
	}

	if password == "" {
		return nil, nil, nil, "", ErrNoPassword
	}

	privKey, _, err := crypto.GenerateKeyPair(crypto.Ed25519, -1)
	if err != nil {
		return nil, nil, nil, "", err
	}

	privBytes, err := crypto.MarshalPrivateKey(privKey)
	if err != nil {
		return nil, nil, nil, "", err
	}

	pub, priv, err := box.GenerateKey(rand.Reader)
	if err != nil {
		return nil, nil, nil, "", err
	}

	newId := LocalIdentity{
		LibP2PPriv: privBytes,
		NaClPub:    pub[:],
		NaClPriv:   priv[:],
	}

	if err := saveEncrypted(IdentityFile, newId.Marshal(), password); err != nil {
		return nil, nil, nil, "", err
	}

	return privKey, pub, priv, "", nil
}

func (n *Node) saveIdentity() error {
	n.mu.RLock()
	password := n.password
	nickname := n.nickname
	n.mu.RUnlock()

	if password == "" {
		return ErrNoPassword
	}

	privBytes, err := crypto.MarshalPrivateKey(n.host.Peerstore().PrivKey(n.host.ID()))
	if err != nil {
		return err
	}

	id := LocalIdentity{
		Nickname:   nickname,
		LibP2PPriv: privBytes,
		NaClPub:    n.naclPublic[:],
		NaClPriv:   n.naclPrivate[:],
	}

	return saveEncrypted(IdentityFile, id.Marshal(), password)
}

func NewNode(ctx context.Context, listener UIListener, password string) (*Node, error) {
	if password == "" {
		return nil, ErrNoPassword
	}

	privKey, naclPub, naclPriv, savedNick, err := loadOrInitIdentity(password)
	if err != nil {
		return nil, err
	}

	var bootstrapPeers []peer.AddrInfo
	for _, addr := range dht.DefaultBootstrapPeers {
		ai, err := peer.AddrInfoFromP2pAddr(addr)
		if err == nil && ai != nil {
			bootstrapPeers = append(bootstrapPeers, *ai)
		}
	}

	h, err := libp2p.New(
		libp2p.Identity(privKey),
		libp2p.ListenAddrStrings("/ip4/0.0.0.0/tcp/0", "/ip4/0.0.0.0/udp/0/quic-v1"),
		libp2p.EnableRelay(),
		libp2p.EnableAutoRelay(autorelay.WithStaticRelays(bootstrapPeers)),
		libp2p.EnableNATService(),
		libp2p.EnableHolePunching(),
	)
	if err != nil {
		return nil, err
	}

	kadDHT, err := dht.New(ctx, h, dht.Mode(dht.ModeAuto), dht.BootstrapPeers(bootstrapPeers...))
	if err != nil {
		return nil, err
	}
	kadDHT.Bootstrap(ctx)

	ctxNode, cancel := context.WithCancel(ctx)
	node := &Node{
		host:         h,
		dht:          kadDHT,
		discovery:    routing.NewRoutingDiscovery(kadDHT),
		nickname:     savedNick,
		password:     password,
		naclPublic:   *naclPub,
		naclPrivate:  *naclPriv,
		contacts:     make(map[peer.ID]*Contact),
		nickMap:      make(map[string]peer.ID),
		ctx:          ctxNode,
		cancel:       cancel,
		presenceChan: make(chan peer.ID, 100),
		listener:     listener,
	}

	h.SetStreamHandler(ProtocolID, node.handleStream)

	node.wg.Add(4)
	go node.keepAliveLoop()
	go node.backgroundAdvertise()
	go node.presenceLoop()
	go node.presenceWorkerPool()

	return node, nil
}

func (n *Node) LoadContacts() error {
	if !ContactsExist() {
		return nil
	}

	n.mu.RLock()
	password := n.password
	n.mu.RUnlock()

	if password == "" {
		return ErrNoPassword
	}

	rawBytes, err := loadEncrypted(ContactsFile, password)
	if err != nil {
		return err
	}

	saved, err := UnmarshalContacts(rawBytes)
	if err != nil {
		return err
	}

	n.mu.Lock()
	defer n.mu.Unlock()

	for _, c := range saved {
		pid, err := peer.Decode(c.PeerID)
		if err != nil {
			continue
		}
		contact := &Contact{
			Nickname:   c.Nickname,
			PeerID:     pid,
			PublicKey:  c.PublicKey,
			SeenNonces: make(map[int64]time.Time),
			State:      StateIdle,
			Presence:   PresenceUnknown,
		}
		n.contacts[contact.PeerID] = contact
		n.nickMap[contact.Nickname] = contact.PeerID
	}

	return nil
}

func (n *Node) SaveContacts() {
	n.mu.RLock()
	password := n.password
	list := make([]SerializableContact, 0, len(n.contacts))
	for _, c := range n.contacts {
		c.mu.Lock()
		list = append(list, SerializableContact{
			Nickname:  c.Nickname,
			PeerID:    c.PeerID.String(),
			PublicKey: c.PublicKey,
		})
		c.mu.Unlock()
	}
	n.mu.RUnlock()

	if password == "" {
		return
	}

	data := MarshalContacts(list)
	if err := saveEncrypted(ContactsFile, data, password); err != nil {
		n.Log(LogLevelError, "Ошибка сохранения контактов: %v", err)
	}
}


------------------------------------------------------------
ПУТЬ: pkg -> f2f -> interfaces.go
------------------------------------------------------------
package f2f

import "time"

// UIListener методы, которые должен реализовать GUI или CLI
type UIListener interface {
	OnMessage(peerID string, nick string, text string, timestamp time.Time)
	OnFileOffer(peerID string, nick string, filename string, size int64)
	OnFileProgress(peerID string, nick string, filename string, progress float64, isUpload bool)
	OnFileReceived(peerID string, nick string, filename string, savedPath string, size int64)
	OnFileComplete(peerID string, nick string, filename string, success bool, message string)
	OnLog(level string, format string, args ...any)
	OnContactUpdate()
	OnChatChanged(peerID string, nick string)
}

const (
	LogLevelInfo    = "INFO"
	LogLevelWarning = "WARN"
	LogLevelError   = "ERR"
	LogLevelSuccess = "OK"
)


------------------------------------------------------------
ПУТЬ: pkg -> f2f -> network.go
------------------------------------------------------------
package f2f

import (
	"context"
	"encoding/binary"
	"errors"
	"fmt"
	"io"
	"time"

	"github.com/libp2p/go-libp2p/core/network"
	"github.com/libp2p/go-libp2p/core/peer"
	"github.com/libp2p/go-libp2p/core/peerstore"
)

// writeFrame пишет фрейм с типом
func (n *Node) writeFrame(s network.Stream, frameType byte, data []byte) error {
	totalLen := 1 + len(data)
	buf := make([]byte, 4+totalLen)
	binary.BigEndian.PutUint32(buf[:4], uint32(totalLen))
	buf[4] = frameType
	copy(buf[5:], data)
	_, err := s.Write(buf)
	return err
}

func (n *Node) writeMsgFrame(s network.Stream, data []byte) error {
	return n.writeFrame(s, FrameTypeMsg, data)
}

func (n *Node) writeBinaryFrame(s network.Stream, data []byte) error {
	return n.writeFrame(s, FrameTypeBinary, data)
}

func (n *Node) readFrame(s network.Stream) (byte, []byte, error) {
	header := make([]byte, 4)
	if _, err := io.ReadFull(s, header); err != nil {
		return 0, nil, err
	}
	length := binary.BigEndian.Uint32(header)
	if length > MaxFrameSize {
		return 0, nil, fmt.Errorf("frame too large: %d", length)
	}
	if length < 1 {
		return 0, nil, errors.New("frame too small")
	}

	buf := make([]byte, length)
	if _, err := io.ReadFull(s, buf); err != nil {
		return 0, nil, err
	}

	frameType := buf[0]
	data := buf[1:]
	return frameType, data, nil
}

func (n *Node) readMsgFrame(s network.Stream) ([]byte, error) {
	frameType, data, err := n.readFrame(s)
	if err != nil {
		return nil, err
	}
	if frameType != FrameTypeMsg {
		return nil, errors.New("expected Msg frame")
	}
	return data, nil
}

func (n *Node) InitConnect(nickname string) {
	c := n.getContactByNick(nickname)
	if c == nil {
		n.Log(LogLevelError, "Контакт '%s' не найден", nickname)
		return
	}

	c.mu.Lock()
	if c.Stream != nil {
		pid := c.PeerID
		c.mu.Unlock()
		n.Log(LogLevelWarning, "Уже подключены к %s", nickname)
		n.EnterChat(pid)
		return
	}
	if c.Connecting {
		c.mu.Unlock()
		return
	}
	c.Connecting = true

	ctx, cancel := context.WithCancel(n.ctx)
	c.connectCtx = ctx
	c.connectCancel = cancel
	pid := c.PeerID
	c.mu.Unlock()

	n.notifyContactUpdate()

	defer func() {
		c.mu.Lock()
		c.Connecting = false
		c.connectCtx = nil
		c.connectCancel = nil
		c.mu.Unlock()
		n.notifyContactUpdate()
	}()

	select {
	case <-ctx.Done():
		return
	default:
	}

	if n.host.Network().Connectedness(pid) != network.Connected {
		n.Log(LogLevelInfo, "Поиск %s...", nickname)
		ctxT, cancelT := context.WithTimeout(ctx, PeerLookupTimeout)
		defer cancelT()

		info, err := n.dht.FindPeer(ctxT, pid)
		if err == nil && len(info.Addrs) > 0 {
			n.host.Peerstore().AddAddrs(pid, info.Addrs, peerstore.PermanentAddrTTL)
		}

		select {
		case <-ctx.Done():
			n.Log(LogLevelInfo, "Подключение отменено")
			return
		default:
		}
	}

	streamCtx, streamCancel := context.WithTimeout(ctx, NewStreamTimeout)
	defer streamCancel()

	s, err := n.host.NewStream(streamCtx, pid, ProtocolID)
	if err != nil {
		select {
		case <-ctx.Done():
			n.Log(LogLevelInfo, "Подключение отменено")
		default:
			n.Log(LogLevelError, "Ошибка подключения: %v", err)
		}
		return
	}

	c.mu.Lock()
	if c.Stream != nil {
		c.mu.Unlock()
		s.Reset()
		n.EnterChat(pid)
		return
	}
	c.Stream = s
	c.Presence = PresenceOnline
	c.LastSeen = time.Now()
	c.FailCount = 0

	ephPriv, ephPub, err := generateEphemeralKeys()
	if err != nil {
		c.mu.Unlock()
		n.closeStream(c)
		return
	}
	c.handshakePriv = ephPriv
	c.handshakePub = ephPub
	c.mu.Unlock()

	hsBytes, err := n.createHandshakeBytes(ephPub)
	if err != nil {
		n.closeStream(c)
		return
	}

	if err := n.writeMsgFrame(s, hsBytes); err != nil {
		n.closeStream(c)
		return
	}

	c.mu.Lock()
	c.State = StatePendingOutgoing
	c.mu.Unlock()

	n.Log(LogLevelSuccess, "Отправлен запрос %s...", nickname)
	n.notifyContactUpdate()

	n.wg.Add(1)
	go n.readLoop(c, true)
}

func (n *Node) handleStream(s network.Stream) {
	remoteID := s.Conn().RemotePeer()
	c := n.getContactByID(remoteID)
	if c == nil {
		s.Reset()
		return
	}

	c.mu.Lock()
	if c.Stream != nil {
		localID := n.host.ID()
		if localID.String() < remoteID.String() {
			c.mu.Unlock()
			s.Reset()
			return
		}
		c.Stream.Reset()
	}

	c.LastConnectTime = time.Now()
	c.Stream = s
	c.Presence = PresenceOnline
	c.LastSeen = time.Now()
	c.FailCount = 0

	ephPriv, ephPub, err := generateEphemeralKeys()
	if err != nil {
		c.mu.Unlock()
		n.closeStream(c)
		return
	}
	c.handshakePriv = ephPriv
	c.handshakePub = ephPub
	c.mu.Unlock()

	n.notifyContactUpdate()

	hsBytes, err := n.createHandshakeBytes(ephPub)
	if err != nil {
		n.closeStream(c)
		return
	}

	if err := n.writeMsgFrame(s, hsBytes); err != nil {
		n.closeStream(c)
		return
	}

	n.wg.Add(1)
	go n.readLoop(c, false)
}

func (n *Node) readLoop(c *Contact, isInitiator bool) {
	defer n.wg.Done()
	defer n.handleDisconnect(c, nil)

	c.mu.Lock()
	s := c.Stream
	c.mu.Unlock()

	if s == nil {
		return
	}

	s.SetReadDeadline(time.Now().Add(HandshakeTimeout))
	hsData, err := n.readMsgFrame(s)
	if err != nil {
		return
	}

	remoteEphPub, err := n.verifyHandshake(c, hsData)
	if err != nil {
		n.Log(LogLevelError, "Handshake fail: %v", err)
		return
	}

	c.mu.Lock()
	initShared, err := deriveSessionKey(c.handshakePriv, c.handshakePub, remoteEphPub)
	if err != nil {
		c.mu.Unlock()
		return
	}

	var bobPub *[32]byte
	if isInitiator {
		bobPub = remoteEphPub
	} else {
		bobPub = nil
	}

	ratchet, err := InitializeRatchet(initShared, bobPub)
	if err != nil {
		c.mu.Unlock()
		return
	}

	c.Ratchet = ratchet
	c.sessionEstab = true
	c.handshakePriv = nil
	c.handshakePub = nil
	c.mu.Unlock()

	n.notifyContactUpdate()

	if isInitiator {
		if err := n.sendSessionMessage(c, MsgTypeRequest, nil); err != nil {
			return
		}
	}

	go n.SaveContacts()

	for {
		c.mu.Lock()
		if c.Stream != s {
			c.mu.Unlock()
			return
		}
		if c.Ratchet == nil {
			c.mu.Unlock()
			return
		}
		c.mu.Unlock()

		s.SetReadDeadline(time.Now().Add(StreamReadTimeout))
		frameType, data, err := n.readFrame(s)
		if err != nil {
			return
		}

		// Double Ratchet Decryption
		if len(data) < 40 {
			continue // Junk
		}

		headerBytes := data[:40]
		ciphertext := data[40:]

		c.mu.Lock()
		plaintext, err := n.RatchetDecrypt(c.Ratchet, headerBytes, ciphertext)
		c.mu.Unlock()

		if err != nil {
			n.Log(LogLevelError, "Decryption error from %s: %v", c.Nickname, err)
			continue
		}

		if frameType == FrameTypeBinary {
			// Передаем расшифрованные данные в file_transfer.go
			n.processBinaryChunk(c, plaintext)
			continue
		}

		msg := &InnerMessage{}
		if err := msg.Unmarshal(plaintext); err != nil {
			continue
		}

		now := time.Now().UnixNano()
		if msg.Timestamp > now+int64(MaxTimeSkew) {
			continue
		}

		c.mu.Lock()
		if msg.Timestamp <= c.LastMsgTime {
			c.mu.Unlock()
			continue
		}
		c.LastMsgTime = msg.Timestamp
		c.mu.Unlock()

		if msg.Type == MsgTypeBye || msg.Type == MsgTypeCancel {
			if msg.Type == MsgTypeCancel {
				n.Log(LogLevelInfo, "%s отменил запрос", c.Nickname)
			}
			return
		}
		if msg.Type == MsgTypePing {
			continue
		}

		content := msg.Content
		if msg.Type == MsgTypeText {
			content = SanitizeInput(content, MaxMsgLength)
		}
		n.processMessage(c, msg.Type, msg.Timestamp, content, msg.Payload)
	}
}

func (n *Node) processMessage(c *Contact, msgType MessageType, ts int64, content string, payload []byte) {
	c.mu.Lock()
	nick := c.Nickname
	pid := c.PeerID
	state := c.State
	c.mu.Unlock()

	switch msgType {
	case MsgTypeRequest:
		if state == StateActive {
			return
		}
		c.mu.Lock()
		c.State = StatePendingIncoming
		c.mu.Unlock()
		n.Log(LogLevelWarning, "Запрос от %s! (.accept / .decline)", nick)
		n.notifyContactUpdate()

	case MsgTypeAccept:
		if state != StatePendingOutgoing {
			return
		}
		c.mu.Lock()
		c.State = StateActive
		c.mu.Unlock()
		n.Log(LogLevelSuccess, "%s принял запрос!", nick)
		n.EnterChat(pid)
		n.notifyContactUpdate()

	case MsgTypeDecline:
		n.closeStream(c)
		n.Log(LogLevelError, "%s отклонил запрос", nick)
		n.notifyContactUpdate()

	case MsgTypeText:
		if state != StateActive {
			return
		}
		timestamp := time.Unix(0, ts)
		n.notifyMessage(pid.String(), nick, content, timestamp)

	case MsgTypeFileOffer:
		n.processFileOffer(c, payload)
	case MsgTypeFileAccept:
		n.processFileAccept(c, payload)
	case MsgTypeFileDecline:
		n.processFileDecline(c, payload)
	case MsgTypeFileCancel:
		n.processFileCancel(c, payload)
	case MsgTypeFileDone:
		n.processFileDone(c, payload)
	}
}

func (n *Node) sendSessionMessage(c *Contact, msgType MessageType, content any) error {
	c.mu.Lock()
	s := c.Stream
	ratchet := c.Ratchet
	c.mu.Unlock()

	if s == nil || ratchet == nil {
		return errors.New("no session")
	}

	msg := &InnerMessage{
		Type:      msgType,
		Timestamp: time.Now().UnixNano(),
	}

	if content != nil {
		switch v := content.(type) {
		case string:
			msg.Content = v
		case []byte:
			msg.Payload = v
		}
	}

	plaintext := msg.Marshal()

	c.mu.Lock()
	headerBytes, ciphertext, err := n.RatchetEncrypt(c.Ratchet, plaintext)
	c.mu.Unlock()

	if err != nil {
		return err
	}

	packet := make([]byte, len(headerBytes)+len(ciphertext))
	copy(packet[0:], headerBytes)
	copy(packet[len(headerBytes):], ciphertext)

	c.writeMu.Lock()
	defer c.writeMu.Unlock()

	s.SetWriteDeadline(time.Now().Add(WriteTimeout))
	return n.writeMsgFrame(s, packet)
}

// FIX: Удален лишний аргумент sessionKey
func (n *Node) sendBinaryChunk(c *Contact, fileID [16]byte, index, total uint32, data []byte) error {
	c.mu.Lock()
	s := c.Stream
	ratchet := c.Ratchet
	c.mu.Unlock()

	if s == nil || ratchet == nil {
		return errors.New("no stream")
	}

	packetInner := make([]byte, BinaryChunkHeaderSize+len(data))
	copy(packetInner[0:16], fileID[:])
	binary.BigEndian.PutUint32(packetInner[16:20], index)
	binary.BigEndian.PutUint32(packetInner[20:24], total)
	copy(packetInner[24:], data)

	c.mu.Lock()
	headerBytes, ciphertext, err := n.RatchetEncrypt(c.Ratchet, packetInner)
	c.mu.Unlock()

	if err != nil {
		return err
	}

	packet := make([]byte, len(headerBytes)+len(ciphertext))
	copy(packet[0:], headerBytes)
	copy(packet[len(headerBytes):], ciphertext)

	c.writeMu.Lock()
	defer c.writeMu.Unlock()

	s.SetWriteDeadline(time.Now().Add(WriteTimeout))
	return n.writeBinaryFrame(s, packet)
}

func (n *Node) closeStream(c *Contact) {
	c.mu.Lock()
	if c.Stream != nil {
		c.Stream.Close()
		c.Stream.Reset()
		c.Stream = nil
	}

	c.Ratchet = nil
	c.State = StateIdle
	c.Connecting = false
	c.sessionEstab = false
	c.PendingFile = nil

	if c.connectCancel != nil {
		c.connectCancel()
		c.connectCancel = nil
		c.connectCtx = nil
	}
	c.mu.Unlock()

	n.notifyContactUpdate()
}

func (n *Node) handleDisconnect(c *Contact, err error) {
	c.mu.Lock()
	nick := c.Nickname
	pid := c.PeerID
	c.mu.Unlock()

	n.closeStream(c)

	n.mu.Lock()
	wasActive := n.activeChat == pid
	if wasActive {
		n.activeChat = ""
	}
	n.mu.Unlock()

	if wasActive {
		n.notifyChatChanged("", "")
		n.Log(LogLevelWarning, "%s отключился", nick)
	}
}

func (n *Node) SendChatMessage(peerID peer.ID, text string) {
	c := n.getContactByID(peerID)
	if c == nil {
		n.LeaveChat()
		return
	}

	c.mu.Lock()
	state := c.State
	c.mu.Unlock()

	if state != StateActive {
		n.Log(LogLevelWarning, "Чат не активен")
		return
	}

	if err := n.sendSessionMessage(c, MsgTypeText, text); err != nil {
		n.Log(LogLevelError, "Ошибка отправки: %v", err)
		return
	}

	n.mu.RLock()
	myNick := n.nickname
	n.mu.RUnlock()

	n.notifyMessage(n.host.ID().String(), myNick, text, time.Now())
}

func (n *Node) sendTerminalMessage(c *Contact, msgType MessageType, content any) {
	c.mu.Lock()
	hasStream := c.Stream != nil
	hasSession := c.sessionEstab
	c.mu.Unlock()

	if hasStream && hasSession {
		if err := n.sendSessionMessage(c, msgType, content); err != nil {
			// Ignore
		}
		select {
		case <-time.After(100 * time.Millisecond):
		case <-n.ctx.Done():
		}
	}
	n.closeStream(c)
}


------------------------------------------------------------
ПУТЬ: pkg -> f2f -> node.go
------------------------------------------------------------
package f2f

import (
	"context"
	"errors"
	"sort"
	"strings"
	"sync"
	"time"

	dht "github.com/libp2p/go-libp2p-kad-dht"
	"github.com/libp2p/go-libp2p/core/host"
	"github.com/libp2p/go-libp2p/core/peer"
	"github.com/libp2p/go-libp2p/p2p/discovery/routing"
)

type Node struct {
	host        host.Host
	dht         *dht.IpfsDHT
	discovery   *routing.RoutingDiscovery
	nickname    string
	password    string
	naclPublic  [32]byte
	naclPrivate [32]byte

	contacts map[peer.ID]*Contact
	nickMap  map[string]peer.ID

	activeChat peer.ID
	mu         sync.RWMutex
	wg         sync.WaitGroup

	ctx    context.Context
	cancel context.CancelFunc

	presenceChan chan peer.ID

	listener UIListener

	isShutdown bool
	shutdownMu sync.Mutex
}

// --- Безопасные методы для работы с UI (Fix #6) ---

func (n *Node) notifyContactUpdate() {
	if n.listener != nil {
		n.listener.OnContactUpdate()
	}
}

func (n *Node) notifyChatChanged(pid, nick string) {
	if n.listener != nil {
		n.listener.OnChatChanged(pid, nick)
	}
}

func (n *Node) notifyMessage(pid, nick, text string, ts time.Time) {
	if n.listener != nil {
		n.listener.OnMessage(pid, nick, text, ts)
	}
}

func (n *Node) notifyFileOffer(pid, nick, filename string, size int64) {
	if n.listener != nil {
		n.listener.OnFileOffer(pid, nick, filename, size)
	}
}

func (n *Node) notifyFileProgress(pid, nick, filename string, progress float64, isUpload bool) {
	if n.listener != nil {
		n.listener.OnFileProgress(pid, nick, filename, progress, isUpload)
	}
}

func (n *Node) notifyFileReceived(pid, nick, filename, path string, size int64) {
	if n.listener != nil {
		n.listener.OnFileReceived(pid, nick, filename, path, size)
	}
}

func (n *Node) notifyFileComplete(pid, nick, filename string, success bool, msg string) {
	if n.listener != nil {
		n.listener.OnFileComplete(pid, nick, filename, success, msg)
	}
}

// --- Валидация (Fix #2) ---

func (n *Node) validateNickname(nick string) error {
	if len(nick) == 0 {
		return errors.New("никнейм не может быть пустым")
	}
	if len(nick) > MaxNickLength {
		return errors.New("никнейм слишком длинный")
	}
	// Дополнительно можно проверить на недопустимые символы
	if strings.TrimSpace(nick) == "" {
		return errors.New("никнейм не может состоять только из пробелов")
	}
	return nil
}

// --- Getters ---

func (n *Node) GetContacts() []*Contact {
	n.mu.RLock()
	defer n.mu.RUnlock()

	list := make([]*Contact, 0, len(n.contacts))
	for _, c := range n.contacts {
		list = append(list, c)
	}

	sort.Slice(list, func(i, j int) bool {
		return list[i].Nickname < list[j].Nickname
	})

	return list
}

func (n *Node) GetActiveChat() peer.ID {
	n.mu.RLock()
	defer n.mu.RUnlock()
	return n.activeChat
}

func (n *Node) GetHostID() string {
	return n.host.ID().String()
}

func (n *Node) GetNickname() string {
	n.mu.RLock()
	defer n.mu.RUnlock()
	return n.nickname
}

func (n *Node) Log(level string, format string, a ...any) {
	if n.listener != nil {
		n.listener.OnLog(level, format, a...)
	}
}

// --- Lifecycle ---

func (n *Node) Shutdown() {
	n.shutdownMu.Lock()
	if n.isShutdown {
		n.shutdownMu.Unlock()
		return
	}
	n.isShutdown = true
	n.shutdownMu.Unlock()

	n.Log(LogLevelInfo, "Завершение...")
	n.cancel()

	select {
	case <-n.presenceChan:
	default:
		close(n.presenceChan)
	}

	n.mu.RLock()
	contacts := make([]*Contact, 0, len(n.contacts))
	for _, c := range n.contacts {
		contacts = append(contacts, c)
	}
	n.mu.RUnlock()

	for _, c := range contacts {
		// Используем новый метод для закрытия (Fix #4)
		n.sendTerminalMessage(c, MsgTypeBye, nil)
	}

	n.SaveContacts()

	done := make(chan struct{})
	go func() {
		n.wg.Wait()
		close(done)
	}()

	select {
	case <-done:
	case <-time.After(ShutdownTimeout):
		n.Log(LogLevelWarning, "Таймаут ожидания горутин")
	}

	n.host.Close()
}

func (n *Node) keepAliveLoop() {
	defer n.wg.Done()
	t := time.NewTicker(KeepAliveInterval)
	defer t.Stop()

	for {
		select {
		case <-n.ctx.Done():
			return
		case <-t.C:
			n.mu.RLock()
			contacts := make([]*Contact, 0)
			for _, c := range n.contacts {
				contacts = append(contacts, c)
			}
			n.mu.RUnlock()

			for _, c := range contacts {
				c.mu.Lock()
				hasStream := c.Stream != nil
				hasSession := c.sessionEstab
				c.mu.Unlock()
				if hasStream && hasSession {
					n.sendSessionMessage(c, MsgTypePing, nil)
				}
			}
		}
	}
}

func (n *Node) backgroundAdvertise() {
	defer n.wg.Done()
	select {
	case <-time.After(AdvertiseDelay):
	case <-n.ctx.Done():
		return
	}
	t := time.NewTicker(AdvertiseInterval)
	defer t.Stop()
	for {
		select {
		case <-n.ctx.Done():
			return
		case <-t.C:
			if len(n.host.Network().Peers()) > 0 {
				n.discovery.Advertise(n.ctx, RendezvousString)
			}
		}
	}
}

func (n *Node) getContactByNick(nick string) *Contact {
	n.mu.RLock()
	defer n.mu.RUnlock()
	if pid, ok := n.nickMap[nick]; ok {
		return n.contacts[pid]
	}
	return nil
}

func (n *Node) getContactByID(id peer.ID) *Contact {
	n.mu.RLock()
	defer n.mu.RUnlock()
	return n.contacts[id]
}

func (n *Node) GetNetworkStatus() (int, bool) {
	if n.host == nil {
		return 0, false
	}

	connectedPeers := len(n.host.Network().Peers())
	hasRelay := false
	for _, addr := range n.host.Addrs() {
		if strings.Contains(addr.String(), "p2p-circuit") {
			hasRelay = true
			break
		}
	}
	return connectedPeers, hasRelay
}


------------------------------------------------------------
ПУТЬ: pkg -> f2f -> presence.go
------------------------------------------------------------
package f2f

import (
	"context"
	"time"

	"github.com/libp2p/go-libp2p/core/network"
	"github.com/libp2p/go-libp2p/core/peer"
	"github.com/libp2p/go-libp2p/core/peerstore"
)

func (n *Node) presenceLoop() {
	defer n.wg.Done()
	select {
	case <-time.After(10 * time.Second):
	case <-n.ctx.Done():
		return
	}
	n.QueuePresenceChecks()
	ticker := time.NewTicker(PresenceInterval)
	defer ticker.Stop()
	for {
		select {
		case <-n.ctx.Done():
			return
		case <-ticker.C:
			n.QueuePresenceChecks()
		}
	}
}

func (n *Node) presenceWorkerPool() {
	defer n.wg.Done()
	for {
		select {
		case <-n.ctx.Done():
			return
		case pid, ok := <-n.presenceChan:
			if !ok {
				return
			}
			n.checkSinglePresence(pid)
		}
	}
}

func (n *Node) ForceCheckAll() {
	n.mu.RLock()
	contacts := make([]*Contact, 0, len(n.contacts))
	for _, c := range n.contacts {
		contacts = append(contacts, c)
	}
	n.mu.RUnlock()

	for _, c := range contacts {
		c.mu.Lock()
		c.NextCheckTime = time.Now()
		c.FailCount = 0
		c.Presence = PresenceChecking
		pid := c.PeerID
		c.mu.Unlock()

		select {
		case n.presenceChan <- pid:
		default:
		}
	}

	n.listener.OnContactUpdate()
}

func (n *Node) QueuePresenceChecks() {
	n.mu.RLock()
	contacts := make([]*Contact, 0, len(n.contacts))
	for _, c := range n.contacts {
		contacts = append(contacts, c)
	}
	n.mu.RUnlock()

	needUpdate := false
	for _, c := range contacts {
		c.mu.Lock()
		if c.Stream != nil {
			c.Presence = PresenceOnline
			c.LastSeen = time.Now()
			c.FailCount = 0
			c.mu.Unlock()
			continue
		}
		if time.Now().Before(c.NextCheckTime) {
			c.mu.Unlock()
			continue
		}
		c.Presence = PresenceChecking
		pid := c.PeerID
		needUpdate = true
		c.mu.Unlock()

		select {
		case n.presenceChan <- pid:
		default:
		}
	}

	if needUpdate {
		n.listener.OnContactUpdate()
	}
}

func (n *Node) checkSinglePresence(pid peer.ID) {
	c := n.getContactByID(pid)
	if c == nil {
		return
	}

	if n.host.Network().Connectedness(pid) == network.Connected {
		c.mu.Lock()
		c.Presence = PresenceOnline
		c.LastSeen = time.Now()
		c.FailCount = 0
		c.NextCheckTime = time.Now().Add(PresenceInterval)
		c.mu.Unlock()
		n.listener.OnContactUpdate()
		return
	}

	ctx, cancel := context.WithTimeout(n.ctx, PresenceTimeout)
	defer cancel()
	info, err := n.dht.FindPeer(ctx, pid)

	c.mu.Lock()
	c.LastChecked = time.Now()
	if err != nil {
		c.Presence = PresenceOffline
		c.FailCount++
		backoff := time.Duration(30*(1<<c.FailCount)) * time.Second
		if backoff > MaxPresenceBackoff {
			backoff = MaxPresenceBackoff
		}
		c.NextCheckTime = time.Now().Add(backoff)
	} else {
		c.Presence = PresenceOnline
		c.LastSeen = time.Now()
		c.AddressCount = len(info.Addrs)
		c.FailCount = 0
		c.NextCheckTime = time.Now().Add(PresenceInterval)
		if len(info.Addrs) > 0 {
			n.host.Peerstore().AddAddrs(pid, info.Addrs, peerstore.TempAddrTTL)
		}
	}
	c.mu.Unlock()

	n.listener.OnContactUpdate()
}

func (n *Node) FindContact(nick string) {
	c := n.getContactByNick(nick)
	if c == nil {
		n.Log(LogLevelError, "Контакт '%s' не найден", nick)
		return
	}

	c.mu.Lock()
	pid := c.PeerID
	c.mu.Unlock()

	n.Log(LogLevelInfo, "Поиск %s в DHT...", nick)

	ctx, cancel := context.WithTimeout(n.ctx, PresenceTimeout)
	defer cancel()

	start := time.Now()
	info, err := n.dht.FindPeer(ctx, pid)
	elapsed := time.Since(start)

	c.mu.Lock()
	c.LastChecked = time.Now()
	if err != nil {
		c.Presence = PresenceOffline
		c.mu.Unlock()
		n.Log(LogLevelError, "%s не найден (%.1fs)", nick, elapsed.Seconds())
	} else {
		c.Presence = PresenceOnline
		c.LastSeen = time.Now()
		c.AddressCount = len(info.Addrs)
		c.FailCount = 0
		c.mu.Unlock()
		n.host.Peerstore().AddAddrs(pid, info.Addrs, peerstore.PermanentAddrTTL)
		n.Log(LogLevelSuccess, "%s найден! (%d адресов, %.1fs)", nick, len(info.Addrs), elapsed.Seconds())
	}

	n.listener.OnContactUpdate()
}


------------------------------------------------------------
ПУТЬ: pkg -> f2f -> types.go
------------------------------------------------------------
package f2f

import (
	"context"
	"encoding/binary"
	"hash"
	"io"
	"os"
	"sync"
	"time"

	"github.com/libp2p/go-libp2p/core/network"
	"github.com/libp2p/go-libp2p/core/peer"
)

// --- Enums ---

type ChatState int

const (
	StateIdle            ChatState = iota
	StatePendingIncoming           // Мне прислали запрос
	StatePendingOutgoing           // Я отправил запрос
	StateActive                    // Чат активен
)

type PresenceStatus int

const (
	PresenceUnknown PresenceStatus = iota
	PresenceOnline
	PresenceOffline
	PresenceChecking
)

func (p PresenceStatus) String() string {
	switch p {
	case PresenceOnline:
		return "ONLINE"
	case PresenceOffline:
		return "OFFLINE"
	case PresenceChecking:
		return "CHECKING..."
	default:
		return "UNKNOWN"
	}
}

// --- Frame Types ---

const (
	FrameTypeMsg    byte = 0x00
	FrameTypeBinary byte = 0x01
)

// --- Message Types ---

type MessageType int

const (
	MsgTypeHandshake MessageType = iota
	MsgTypeRequest
	MsgTypeAccept
	MsgTypeDecline
	MsgTypeCancel
	MsgTypeText
	MsgTypePing
	MsgTypeBye

	// PCS / Ratchet messages
	// MsgTypeRekey и MsgTypeRekeyAck УДАЛЕНЫ, так как Double Ratchet встроен в протокол

	// File transfer messages
	MsgTypeFileOffer
	MsgTypeFileAccept
	MsgTypeFileDecline
	MsgTypeFileCancel
	MsgTypeFileDone
)

// --- Serialization Helpers ---
// (Buffer implementation omitted for brevity - same as before)
type Buffer struct {
	data   []byte
	offset int
}

func NewBuffer(data []byte) *Buffer {
	return &Buffer{data: data, offset: 0}
}

func (b *Buffer) WriteByte(v byte) {
	b.data = append(b.data, v)
}

func (b *Buffer) WriteUint32(v uint32) {
	tmp := make([]byte, 4)
	binary.BigEndian.PutUint32(tmp, v)
	b.data = append(b.data, tmp...)
}

func (b *Buffer) WriteInt64(v int64) {
	tmp := make([]byte, 8)
	binary.BigEndian.PutUint64(tmp, uint64(v))
	b.data = append(b.data, tmp...)
}

func (b *Buffer) WriteBytes(v []byte) {
	b.WriteUint32(uint32(len(v)))
	b.data = append(b.data, v...)
}

func (b *Buffer) WriteString(v string) {
	b.WriteBytes([]byte(v))
}

func (b *Buffer) WriteFixed32(v [32]byte) {
	b.data = append(b.data, v[:]...)
}

func (b *Buffer) ReadByte() (byte, error) {
	if b.offset >= len(b.data) {
		return 0, io.ErrUnexpectedEOF
	}
	v := b.data[b.offset]
	b.offset++
	return v, nil
}

func (b *Buffer) ReadUint32() (uint32, error) {
	if b.offset+4 > len(b.data) {
		return 0, io.ErrUnexpectedEOF
	}
	v := binary.BigEndian.Uint32(b.data[b.offset:])
	b.offset += 4
	return v, nil
}

func (b *Buffer) ReadInt64() (int64, error) {
	if b.offset+8 > len(b.data) {
		return 0, io.ErrUnexpectedEOF
	}
	v := int64(binary.BigEndian.Uint64(b.data[b.offset:]))
	b.offset += 8
	return v, nil
}

func (b *Buffer) ReadBytes() ([]byte, error) {
	l, err := b.ReadUint32()
	if err != nil {
		return nil, err
	}
	if b.offset+int(l) > len(b.data) {
		return nil, io.ErrUnexpectedEOF
	}
	v := make([]byte, l)
	copy(v, b.data[b.offset:b.offset+int(l)])
	b.offset += int(l)
	return v, nil
}

func (b *Buffer) ReadString() (string, error) {
	bs, err := b.ReadBytes()
	if err != nil {
		return "", err
	}
	return string(bs), nil
}

func (b *Buffer) ReadFixed32() ([32]byte, error) {
	var out [32]byte
	if b.offset+32 > len(b.data) {
		return out, io.ErrUnexpectedEOF
	}
	copy(out[:], b.data[b.offset:b.offset+32])
	b.offset += 32
	return out, nil
}

func (b *Buffer) Bytes() []byte {
	return b.data
}

// --- Protocol Messages ---

type InnerMessage struct {
	Type      MessageType
	Timestamp int64
	Content   string
	Payload   []byte
}

func (m *InnerMessage) Marshal() []byte {
	b := NewBuffer(make([]byte, 0, 128))
	b.WriteUint32(uint32(m.Type))
	b.WriteInt64(m.Timestamp)
	b.WriteString(m.Content)
	b.WriteBytes(m.Payload)
	return b.Bytes()
}

func (m *InnerMessage) Unmarshal(data []byte) error {
	b := NewBuffer(data)
	t, err := b.ReadUint32()
	if err != nil {
		return err
	}
	m.Type = MessageType(t)
	m.Timestamp, err = b.ReadInt64()
	if err != nil {
		return err
	}
	m.Content, err = b.ReadString()
	if err != nil {
		return err
	}
	m.Payload, err = b.ReadBytes()
	return err
}

type HandshakePayload struct {
	Version      string
	Timestamp    int64
	Nonce        int64
	NaClPubKey   []byte
	EphemeralPub []byte
	Signature    []byte
}

func (h *HandshakePayload) Marshal() []byte {
	b := NewBuffer(make([]byte, 0, 256))
	b.WriteString(h.Version)
	b.WriteInt64(h.Timestamp)
	b.WriteInt64(h.Nonce)
	b.WriteBytes(h.NaClPubKey)
	b.WriteBytes(h.EphemeralPub)
	b.WriteBytes(h.Signature)
	return b.Bytes()
}

func (h *HandshakePayload) Unmarshal(data []byte) error {
	b := NewBuffer(data)
	var err error
	h.Version, err = b.ReadString()
	if err != nil {
		return err
	}
	h.Timestamp, err = b.ReadInt64()
	if err != nil {
		return err
	}
	h.Nonce, err = b.ReadInt64()
	if err != nil {
		return err
	}
	h.NaClPubKey, err = b.ReadBytes()
	if err != nil {
		return err
	}
	h.EphemeralPub, err = b.ReadBytes()
	if err != nil {
		return err
	}
	h.Signature, err = b.ReadBytes()
	return err
}

// --- Double Ratchet Structures ---

// RatchetHeader отправляется с каждым зашифрованным сообщением
type RatchetHeader struct {
	PublicKey [32]byte // Текущий DH ключ отправителя
	PN        uint32   // Количество сообщений в предыдущей цепочке
	N         uint32   // Номер сообщения в текущей цепочке
}

func (rh *RatchetHeader) Marshal() []byte {
	// Fixed size: 32 + 4 + 4 = 40 bytes
	buf := make([]byte, 40)
	copy(buf[0:32], rh.PublicKey[:])
	binary.BigEndian.PutUint32(buf[32:36], rh.PN)
	binary.BigEndian.PutUint32(buf[36:40], rh.N)
	return buf
}

func (rh *RatchetHeader) Unmarshal(data []byte) error {
	if len(data) < 40 {
		return io.ErrUnexpectedEOF
	}
	copy(rh.PublicKey[:], data[0:32])
	rh.PN = binary.BigEndian.Uint32(data[32:36])
	rh.N = binary.BigEndian.Uint32(data[36:40])
	return nil
}

// SkippedKey хранит ключи для пропущенных сообщений (out-of-order)
type SkippedKey struct {
	Key       [32]byte
	Timestamp time.Time
}

// RatchetState хранит состояние Double Ratchet
type RatchetState struct {
	// KDF Chains
	RootKey   [32]byte
	ChainKeyS [32]byte // Sending chain key
	ChainKeyR [32]byte // Receiving chain key

	// DH Ratchet
	DHLocalPriv *[32]byte
	DHLocalPub  *[32]byte
	DHRemotePub *[32]byte // Последний известный ключ собеседника

	// Counts
	Ns uint32 // Sending message number
	Nr uint32 // Receiving message number
	PN uint32 // Count of previous receiving chain

	// Skipped Message Keys for handling out-of-order messages
	// Map: HeaderKey(Pub+N) -> MessageKey
	SkippedMsgKeys map[[36]byte]SkippedKey
}

// --- File Transfer Types ---

type FileOffer struct {
	ID   string
	Name string
	Size int64
}

func (f *FileOffer) Marshal() []byte {
	b := NewBuffer(make([]byte, 0, 64))
	b.WriteString(f.ID)
	b.WriteString(f.Name)
	b.WriteInt64(f.Size)
	return b.Bytes()
}

func (f *FileOffer) Unmarshal(data []byte) error {
	b := NewBuffer(data)
	var err error
	f.ID, err = b.ReadString()
	if err != nil {
		return err
	}
	f.Name, err = b.ReadString()
	if err != nil {
		return err
	}
	f.Size, err = b.ReadInt64()
	return err
}

type FileResponse struct {
	ID string
}

func (f *FileResponse) Marshal() []byte {
	b := NewBuffer(make([]byte, 0, 32))
	b.WriteString(f.ID)
	return b.Bytes()
}

func (f *FileResponse) Unmarshal(data []byte) error {
	b := NewBuffer(data)
	var err error
	f.ID, err = b.ReadString()
	return err
}

// BinaryChunkHeader - заголовок бинарного чанка
type BinaryChunkHeader struct {
	FileID [16]byte
	Index  uint32
	Total  uint32
}

const BinaryChunkHeaderSize = 16 + 4 + 4 // 24 bytes

type FileDone struct {
	ID   string
	Hash string // sha256 hex
}

func (f *FileDone) Marshal() []byte {
	b := NewBuffer(make([]byte, 0, 64))
	b.WriteString(f.ID)
	b.WriteString(f.Hash)
	return b.Bytes()
}

func (f *FileDone) Unmarshal(data []byte) error {
	b := NewBuffer(data)
	var err error
	f.ID, err = b.ReadString()
	if err != nil {
		return err
	}
	f.Hash, err = b.ReadString()
	return err
}

type FileTransfer struct {
	ID          string
	IDBinary    [16]byte
	Name        string
	Size        int64
	FilePath    string
	TempPath    string
	TempFile    *os.File
	Hasher      hash.Hash
	Received    int64
	ChunksSent  int
	ChunksRecv  int
	TotalChunks int
	CreatedAt   time.Time
	IsOutgoing  bool
	Cancelled   bool
}

// --- Contact ---

type Contact struct {
	Nickname    string
	PeerID      peer.ID
	PublicKey   [32]byte
	LastMsgTime int64

	SeenNonces map[int64]time.Time

	State           ChatState
	Stream          network.Stream
	Connecting      bool
	LastConnectTime time.Time

	connectCtx    context.Context
	connectCancel context.CancelFunc

	Presence      PresenceStatus
	LastSeen      time.Time
	LastChecked   time.Time
	AddressCount  int
	FailCount     int
	NextCheckTime time.Time

	// Double Ratchet State
	// Заменяет простые sessionKey
	Ratchet      *RatchetState
	sessionEstab bool

	// Ephemeral keys for initial handshake only
	handshakePriv *[32]byte
	handshakePub  *[32]byte

	PendingFile *FileTransfer

	mu      sync.Mutex
	writeMu sync.Mutex
}

// --- Identity ---

type LocalIdentity struct {
	Nickname   string
	LibP2PPriv []byte
	NaClPub    []byte
	NaClPriv   []byte
}

func (id *LocalIdentity) Marshal() []byte {
	b := NewBuffer(make([]byte, 0, 512))
	b.WriteString(id.Nickname)
	b.WriteBytes(id.LibP2PPriv)
	b.WriteBytes(id.NaClPub)
	b.WriteBytes(id.NaClPriv)
	return b.Bytes()
}

func (id *LocalIdentity) Unmarshal(data []byte) error {
	b := NewBuffer(data)
	var err error
	id.Nickname, err = b.ReadString()
	if err != nil {
		return err
	}
	id.LibP2PPriv, err = b.ReadBytes()
	if err != nil {
		return err
	}
	id.NaClPub, err = b.ReadBytes()
	if err != nil {
		return err
	}
	id.NaClPriv, err = b.ReadBytes()
	return err
}

type SerializableContact struct {
	Nickname  string
	PeerID    string
	PublicKey [32]byte
}

func MarshalContacts(contacts []SerializableContact) []byte {
	b := NewBuffer(make([]byte, 0, 1024))
	b.WriteUint32(uint32(len(contacts)))
	for _, c := range contacts {
		b.WriteString(c.Nickname)
		b.WriteString(c.PeerID)
		b.WriteFixed32(c.PublicKey)
	}
	return b.Bytes()
}

func UnmarshalContacts(data []byte) ([]SerializableContact, error) {
	b := NewBuffer(data)
	count, err := b.ReadUint32()
	if err != nil {
		return nil, err
	}
	contacts := make([]SerializableContact, count)
	for i := uint32(0); i < count; i++ {
		contacts[i].Nickname, err = b.ReadString()
		if err != nil {
			return nil, err
		}
		contacts[i].PeerID, err = b.ReadString()
		if err != nil {
			return nil, err
		}
		contacts[i].PublicKey, err = b.ReadFixed32()
		if err != nil {
			return nil, err
		}
	}
	return contacts, nil
}


------------------------------------------------------------
ПУТЬ: pkg -> f2f -> ui_helpers.go
------------------------------------------------------------
package f2f

import (
	"strings"
	"unicode"
	"unicode/utf8"
)

func visibleLen(s string) int {
	return utf8.RuneCountInString(s)
}

func SanitizeInput(input string, maxLen int) string {
	runes := []rune(strings.TrimSpace(input))
	safeRunes := make([]rune, 0, len(runes))
	for _, r := range runes {
		if unicode.IsPrint(r) {
			safeRunes = append(safeRunes, r)
		}
	}
	if len(safeRunes) > maxLen {
		return string(safeRunes[:maxLen])
	}
	return string(safeRunes)
}


------------------------------------------------------------
ПУТЬ: cmd -> cli -> main.go
------------------------------------------------------------
package main

import (
	"context"
	"encoding/base64"
	"fmt"
	"os"
	"runtime"
	"strings"
	"time"

	"github.com/TheSiriuss/F2F-chat/pkg/f2f"
	"github.com/chzyer/readline"
	"golang.org/x/term"
)

func main() {
	initStyle()
	enableANSI()

	rl, err := readline.NewEx(&readline.Config{
		Prompt:          "> ",
		InterruptPrompt: "^C",
		EOFPrompt:       ".exit",
	})
	if err != nil {
		panic(err)
	}
	defer func() { _ = rl.Close() }()

	ui := &ConsoleAdapter{rl: rl}

	fmt.Print("\033[H\033[2J")
	ui.PrintBanner()

	password, err := getPassword(ui)
	if err != nil {
		fmt.Println("Ошибка:", err)
		return
	}

	ctx := context.Background()
	node, err := f2f.NewNode(ctx, ui, password)
	if err != nil {
		if err == f2f.ErrWrongPassword {
			fmt.Println("Неверный пароль!")
		} else {
			fmt.Println("Critical Error:", err)
		}
		return
	}

	if err := node.LoadContacts(); err != nil {
		// Silent fail
	}

	if node.GetNickname() != "" {
		ui.OnLog(f2f.LogLevelSuccess, "Авто-вход: %s", node.GetNickname())
		go func() {
			time.Sleep(200 * time.Millisecond)
			printNodeInfo(ui, node)
		}()
	} else {
		ui.OnLog(f2f.LogLevelInfo, "Введите .login <ник> для создания профиля")
	}

	for {
		line, err := rl.Readline()
		if err != nil {
			break
		}

		if !strings.HasPrefix(line, ".") {
			active := node.GetActiveChat()
			if active.String() != "" {
				cleanMsg := SanitizeInput(line, f2f.MaxMsgLength)
				if cleanMsg != "" {
					clearInputLine()
					node.SendChatMessage(active, cleanMsg)
				}
			} else {
				if strings.TrimSpace(line) != "" {
					ui.OnLog(f2f.LogLevelWarning, "Вы не в чате. Используйте команды или .connect")
				}
			}
			continue
		}

		parts := strings.Fields(line)
		if len(parts) == 0 {
			continue
		}
		cmd := strings.ToLower(parts[0])

		switch cmd {
		case ".login":
			if len(parts) > 1 {
				cleanNick := SanitizeInput(parts[1], 32)
				node.Login(cleanNick)
				printNodeInfo(ui, node)
			} else {
				ui.OnLog(f2f.LogLevelInfo, "Использование: .login <ник>")
			}
		case ".logout":
			node.Logout()

		case ".removefriend", ".remove", ".unfriend":
			if len(parts) > 1 {
				node.RemoveFriend(parts[1])
			} else {
				ui.OnLog(f2f.LogLevelInfo, "Использование: .removefriend <nick>")
			}

		case ".bootstrap":
			go node.ConnectToBootstrap()

		case ".info":
			printNodeInfo(ui, node)

		case ".fingerprint":
			if len(parts) > 1 {
				ui.OnLog(f2f.LogLevelInfo, "Пока работает только для своего ключа (без аргументов)")
			} else {
				idStr := node.GetIdentityString()
				idParts := strings.Fields(idStr)
				if len(idParts) >= 4 {
					pubKeyBytes, _ := base64.StdEncoding.DecodeString(idParts[3])
					fp := f2f.ComputeFingerprint(pubKeyBytes)
					ui.DrawBox("ВАШ FINGERPRINT", []string{fp})
				} else {
					ui.OnLog(f2f.LogLevelWarning, "Сначала залогиньтесь")
				}
			}

		case ".addfriend", ".add":
			if len(parts) >= 4 {
				node.AddFriend(parts[1], parts[2], parts[3])
			} else {
				ui.OnLog(f2f.LogLevelInfo, "Использование: .addfriend <nick> <peerID> <pubkey>")
			}

		case ".connect":
			if len(parts) > 1 {
				go node.InitConnect(parts[1])
			} else {
				ui.OnLog(f2f.LogLevelInfo, "Использование: .connect <nick>")
			}

		case ".disconnect":
			if len(parts) > 1 {
				node.Disconnect(parts[1])
			} else {
				active := node.GetActiveChat()
				if active.String() != "" {
					node.DisconnectByPeerID(active)
				} else {
					ui.OnLog(f2f.LogLevelInfo, "Использование: .disconnect <nick> или .disconnect (в активном чате)")
				}
			}

		case ".accept":
			if len(parts) > 1 {
				node.HandleDecision(parts[1], true)
			} else {
				ui.OnLog(f2f.LogLevelInfo, "Использование: .accept <nick>")
			}

		case ".decline":
			if len(parts) > 1 {
				node.HandleDecision(parts[1], false)
			} else {
				ui.OnLog(f2f.LogLevelInfo, "Использование: .decline <nick>")
			}

		case ".leave":
			node.LeaveChat()

		case ".file":
			if len(parts) > 1 {
				active := node.GetActiveChat()
				if active.String() == "" {
					ui.OnLog(f2f.LogLevelWarning, "Вы не в чате. Сначала подключитесь к контакту")
					break
				}
				filePath := strings.Join(parts[1:], " ")
				if err := node.SendFile(active, filePath); err != nil {
					ui.OnLog(f2f.LogLevelError, "Ошибка: %v", err)
				}
			} else {
				ui.OnLog(f2f.LogLevelInfo, "Использование: .file <путь к файлу>")
			}

		case ".getfile":
			active := node.GetActiveChat()
			if active.String() == "" {
				ui.OnLog(f2f.LogLevelWarning, "Вы не в чате")
				break
			}
			if err := node.AcceptFile(""); err != nil {
				ui.OnLog(f2f.LogLevelError, "Ошибка: %v", err)
			}

		case ".nofile":
			active := node.GetActiveChat()
			if active.String() == "" {
				ui.OnLog(f2f.LogLevelWarning, "Вы не в чате")
				break
			}
			if err := node.DeclineFile(""); err != nil {
				ui.OnLog(f2f.LogLevelError, "Ошибка: %v", err)
			}

		case ".list":
			contacts := node.GetContacts()
			var lines []string
			if len(contacts) == 0 {
				lines = append(lines, "(пусто)")
			}
			for _, c := range contacts {
				icon := Style.Offline
				status := "OFFLINE"
				if c.Stream != nil {
					icon = Style.Connected
					status = "CONNECTED"
				} else if c.State == f2f.StateActive {
					icon = Style.InChat
					status = "IN CHAT"
				} else if c.State == f2f.StatePendingOutgoing {
					icon = Style.Pending
					status = "CONNECTING..."
				} else if c.State == f2f.StatePendingIncoming {
					icon = Style.Bell
					status = "INCOMING REQUEST"
				} else if c.Connecting {
					icon = Style.Searching
					status = "SEARCHING..."
				} else if c.Presence == f2f.PresenceOnline {
					icon = Style.Online
					status = "ONLINE"
				}

				lines = append(lines, fmt.Sprintf("%s %-12s %s", icon, c.Nickname, status))
			}
			ui.DrawBox("КОНТАКТЫ", lines)

		case ".check":
			ui.OnLog(f2f.LogLevelInfo, "Проверка статусов...")
			node.ForceCheckAll()

		case ".find":
			if len(parts) > 1 {
				go node.FindContact(parts[1])
			}

		case ".help":
			ui.PrintHelp()

		case ".exit", ".quit":
			node.Shutdown()
			return

		default:
			ui.OnLog(f2f.LogLevelWarning, "Неизвестная команда. Введите .help")
		}
	}
	node.Shutdown()
}

func clearInputLine() {
	fmt.Print("\033[1A\033[2K")
}

func enableANSI() {
	if runtime.GOOS == "windows" {
		// Just a placeholder
	}
}

func getPassword(ui *ConsoleAdapter) (string, error) {
	isNew := f2f.IsNewUser()

	if isNew {
		ui.DrawBox("НОВЫЙ ПОЛЬЗОВАТЕЛЬ", []string{
			"Создайте мастер-пароль для защиты ваших данных.",
			"Шифрование: XChaCha20-Poly1305 + Argon2id.",
			"ВНИМАНИЕ: Пароль нельзя восстановить!",
		})
	} else {
		ui.OnLog(f2f.LogLevelInfo, "Введите мастер-пароль:")
	}

	fmt.Print("Пароль: ")
	password, err := readPassword()
	if err != nil {
		return "", err
	}
	fmt.Println()

	if isNew {
		fmt.Print("Подтвердите пароль: ")
		confirm, err := readPassword()
		if err != nil {
			return "", err
		}
		fmt.Println()

		if password != confirm {
			return "", fmt.Errorf("пароли не совпадают")
		}

		if len(password) < 8 {
			return "", fmt.Errorf("пароль слишком короткий (минимум 8 символов)")
		}
	}

	return password, nil
}

func readPassword() (string, error) {
	password, err := term.ReadPassword(int(os.Stdin.Fd()))
	if err != nil {
		return "", err
	}
	return string(password), nil
}

func printNodeInfo(ui *ConsoleAdapter, node *f2f.Node) {
	if node.GetNickname() == "" {
		ui.OnLog(f2f.LogLevelWarning, "Вы не залогинены")
		return
	}

	peers, hasRelay := node.GetNetworkStatus()

	var statusLine string
	if hasRelay {
		statusLine = fmt.Sprintf("%s GLOBAL (relay)", Style.Global)
	} else if peers > 0 {
		statusLine = fmt.Sprintf("%s ONLINE", Style.Online)
	} else {
		statusLine = fmt.Sprintf("%s OFFLINE", Style.Offline)
	}

	rawString := node.GetIdentityString()
	idParts := strings.Fields(rawString)

	var lines []string
	lines = append(lines, fmt.Sprintf("Ник:    %s", node.GetNickname()))
	lines = append(lines, fmt.Sprintf("Статус: %s", statusLine))
	lines = append(lines, fmt.Sprintf("Пиров:  %d", peers))
	lines = append(lines, fmt.Sprintf("PeerID: %s", node.GetHostID()))

	if len(idParts) >= 4 {
		pubKey := idParts[3]
		bytes, _ := base64.StdEncoding.DecodeString(pubKey)
		fp := f2f.ComputeFingerprint(bytes)
		lines = append(lines, fmt.Sprintf("FP:     %s", fp))
		lines = append(lines, "")
		lines = append(lines, "Команда для друга:")
		lines = append(lines, rawString)
	}

	ui.DrawBox("ВАШИ ДАННЫЕ", lines)
}


------------------------------------------------------------
ПУТЬ: cmd -> cli -> style.go
------------------------------------------------------------
package main

import (
	"os"
	"runtime"
)

type UIStyle struct {
	TopLeft, TopRight, BottomLeft, BottomRight string
	Horizontal, Vertical, TeeLeft, TeeRight    string
	Online, Offline, InChat, Connected         string
	Pending, Global, Searching, Unknown        string
	OK, Fail, Warning, Info, Arrow, Bell, Mail string
}

var Style UIStyle

func initStyle() {
	useUnicode := runtime.GOOS != "windows"
	if os.Getenv("F2F_ASCII") == "1" {
		useUnicode = false
	}
	if os.Getenv("F2F_UNICODE") == "1" {
		useUnicode = true
	}

	if useUnicode {
		Style = UIStyle{
			TopLeft: "┌", TopRight: "┐", BottomLeft: "└", BottomRight: "┘",
			Horizontal: "─", Vertical: "│", TeeLeft: "├", TeeRight: "┤",
			Online: "[*]", Offline: "[-]", InChat: "[#]", Connected: "[+]",
			Pending: "[~]", Global: "[G]", Searching: "[?]", Unknown: "[.]",
			OK: "[+]", Fail: "[!]", Warning: "[!]", Info: "[i]",
			Arrow: "->", Bell: "[!]", Mail: "[>]",
		}
	} else {
		Style = UIStyle{
			TopLeft: "+", TopRight: "+", BottomLeft: "+", BottomRight: "+",
			Horizontal: "-", Vertical: "|", TeeLeft: "+", TeeRight: "+",
			Online: "[*]", Offline: "[-]", InChat: "[#]", Connected: "[+]",
			Pending: "[~]", Global: "[G]", Searching: "[?]", Unknown: "[.]",
			OK: "[+]", Fail: "[X]", Warning: "[!]", Info: "[i]",
			Arrow: "->", Bell: "[!]", Mail: "[>]",
		}
	}
}


------------------------------------------------------------
ПУТЬ: cmd -> cli -> ui.go
------------------------------------------------------------
package main

import (
	"fmt"
	"strings"
	"time"
	"unicode"
	"unicode/utf8"

	"github.com/TheSiriuss/F2F-chat/pkg/f2f"
	"github.com/chzyer/readline"
)

type ConsoleAdapter struct {
	rl *readline.Instance
}

func (c *ConsoleAdapter) OnLog(level string, format string, args ...any) {
	c.rl.Clean()
	prefix := ""
	switch level {
	case f2f.LogLevelSuccess:
		prefix = Style.OK + " "
	case f2f.LogLevelError:
		prefix = Style.Fail + " "
	case f2f.LogLevelWarning:
		prefix = Style.Warning + " "
	case f2f.LogLevelInfo:
		prefix = Style.Info + " "
	}
	fmt.Printf(prefix+format+"\n", args...)
	c.rl.Refresh()
}

func (c *ConsoleAdapter) OnMessage(peerID string, nick string, text string, timestamp time.Time) {
	c.rl.Clean()
	fmt.Printf("[%s %s] > %s\n", nick, timestamp.Format("15:04:05"), text)
	c.rl.Refresh()
}

func (c *ConsoleAdapter) OnFileOffer(peerID string, nick string, filename string, size int64) {
	c.rl.Clean()
	fmt.Printf("\n%s %s предлагает файл: %s (%s)\n", Style.Bell, nick, filename, formatSize(size))
	fmt.Printf("%s Используйте .getfile для принятия или .nofile для отклонения\n\n", Style.Info)
	c.rl.Refresh()
}

func (c *ConsoleAdapter) OnFileProgress(peerID string, nick string, filename string, progress float64, isUpload bool) {
	c.rl.Clean()

	barWidth := 30
	filled := int(progress * float64(barWidth))
	if filled > barWidth {
		filled = barWidth
	}
	bar := strings.Repeat("█", filled) + strings.Repeat("░", barWidth-filled)

	direction := "Получение"
	if isUpload {
		direction = "Отправка"
	}

	fmt.Printf("\r%s %s [%s] %.0f%%", direction, filename, bar, progress*100)

	if progress >= 1.0 {
		fmt.Println()
	}
	c.rl.Refresh()
}

func (c *ConsoleAdapter) OnFileReceived(peerID string, nick string, filename string, savedPath string, size int64) {
	c.rl.Clean()
	fmt.Printf("%s Файл от %s сохранён: %s (%s)\n", Style.Mail, nick, savedPath, formatSize(size))
	c.rl.Refresh()
}

func (c *ConsoleAdapter) OnFileComplete(peerID string, nick string, filename string, success bool, message string) {
	c.rl.Clean()
	if success {
		fmt.Printf("%s Передача '%s' завершена: %s\n", Style.OK, filename, message)
	} else {
		fmt.Printf("%s Передача '%s' не удалась: %s\n", Style.Fail, filename, message)
	}
	c.rl.Refresh()
}

func (c *ConsoleAdapter) OnContactUpdate() {
	// В консоли не перерисовываем автоматом
}

func (c *ConsoleAdapter) OnChatChanged(peerID string, nick string) {
	c.rl.Clean()
	if nick != "" {
		c.rl.SetPrompt(fmt.Sprintf("[%s] > ", nick))
		fmt.Printf("\n%s Чат с %s. Forward Secrecy: ON (XChaCha20)\n", Style.Info, nick)
	} else {
		c.rl.SetPrompt("> ")
	}
	c.rl.Refresh()
}

func (c *ConsoleAdapter) DrawBox(title string, lines []string) {
	c.rl.Clean()
	defer c.rl.Refresh()

	contentWidth := 0
	if title != "" {
		contentWidth = visibleLen(title)
	}
	for _, line := range lines {
		l := visibleLen(line)
		if l > contentWidth {
			contentWidth = l
		}
	}
	if contentWidth < 40 {
		contentWidth = 40
	}

	fmt.Print("\n" + Style.TopLeft)
	fmt.Print(strings.Repeat(Style.Horizontal, contentWidth+2))
	fmt.Println(Style.TopRight)

	if title != "" {
		tLen := visibleLen(title)
		padding := (contentWidth - tLen) / 2
		rightPadding := contentWidth - tLen - padding

		fmt.Print(Style.Vertical + " ")
		fmt.Print(strings.Repeat(" ", padding))
		fmt.Print(title)
		fmt.Print(strings.Repeat(" ", rightPadding))
		fmt.Println(" " + Style.Vertical)

		fmt.Print(Style.TeeLeft)
		fmt.Print(strings.Repeat(Style.Horizontal, contentWidth+2))
		fmt.Println(Style.TeeRight)
	}

	for _, line := range lines {
		lLen := visibleLen(line)
		rightPadding := contentWidth - lLen

		fmt.Print(Style.Vertical + " ")
		fmt.Print(line)
		fmt.Print(strings.Repeat(" ", rightPadding))
		fmt.Println(" " + Style.Vertical)
	}

	fmt.Print(Style.BottomLeft)
	fmt.Print(strings.Repeat(Style.Horizontal, contentWidth+2))
	fmt.Println(Style.BottomRight)
}

func (c *ConsoleAdapter) PrintBanner() {
	c.DrawBox(fmt.Sprintf("F2F MESSENGER %s", f2f.ProtocolVersion), []string{
		"Forward Secrecy ENABLED (XChaCha20-Poly1305)",
		".help - справка | Ctrl+C - выход",
	})
}

func (c *ConsoleAdapter) PrintHelp() {
	c.DrawBox("КОМАНДЫ", []string{
		".login <nick>          - создать/войти в профиль",
		".logout                - выйти из профиля",
		".bootstrap             - подключиться к DHT",
		".info                  - мои данные",
		".fingerprint           - fingerprint ключа",
		".addfriend <n> <p> <k> - добавить контакт",
		".removefriend <nick>   - удалить контакт",
		".connect <nick>        - начать чат",
		".disconnect [nick]     - разорвать соединение",
		".accept / .decline     - ответ на запрос чата",
		".leave                 - выйти из чата",
		"",
		"--- Файлы ---",
		".file <путь>           - предложить файл",
		".getfile               - принять файл",
		".nofile                - отклонить/отменить файл",
		"",
		".list                  - контакты",
		".check                 - обновить статусы",
		".find <nick>           - найти в DHT",
		".exit или Ctrl+C       - выход",
	})
}

func visibleLen(s string) int {
	return utf8.RuneCountInString(s)
}

func SanitizeInput(input string, maxLen int) string {
	runes := []rune(strings.TrimSpace(input))
	safeRunes := make([]rune, 0, len(runes))
	for _, r := range runes {
		if unicode.IsPrint(r) {
			safeRunes = append(safeRunes, r)
		}
	}
	if len(safeRunes) > maxLen {
		return string(safeRunes[:maxLen])
	}
	return string(safeRunes)
}

func formatSize(bytes int64) string {
	const (
		KB = 1024
		MB = 1024 * KB
		GB = 1024 * MB
	)
	switch {
	case bytes >= GB:
		return fmt.Sprintf("%.2f GB", float64(bytes)/GB)
	case bytes >= MB:
		return fmt.Sprintf("%.2f MB", float64(bytes)/MB)
	case bytes >= KB:
		return fmt.Sprintf("%.2f KB", float64(bytes)/KB)
	default:
		return fmt.Sprintf("%d B", bytes)
	}
}

